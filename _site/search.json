[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Introduction",
    "section": "",
    "text": "Explore the evolving climate trends in Southeastern Utah through a comprehensive data-driven analysis highlighting significant changes in temperatures, soil moisture, evaporation and precipitation over the years\n\nOverview\nFor the preservation of Southeastern Utah Group National Parks, it is essential to understand the trends that lie in the evolving climate conditions and how they might impact the region‚Äôs delicate ecosystems. This is an in-depth exploration and analysis of the interconnected effects of heat, soil conditions, and precipitation on the national parks.\n\n\nCode\nlibrary(reticulate)\n\nuse_condaenv(\"base\", required = TRUE)\n\n\n\n\nTemperature Tales\n\n\nCode\nimport pandas as pd\nimport plotly.express as px\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport seaborn as sns\n\n# Load the cleaned datasets\nhistoric_data_1 = pd.read_csv('./data/clean-data/historic_data_cleaned.csv')\nnearterm_data_1 = pd.read_csv('./data/clean-data/nearterm_data_cleaned.csv')\n\n# Combine datasets for some visualizations\ncombined_data_1 = pd.concat([historic_data_1, nearterm_data_1])\n\n# Calculate the center of the map\ncenter_lat_1 = combined_data_1['lat'].mean()\ncenter_long_1 = combined_data_1['long'].mean()\n\n# Function to calculate an appropriate zoom level based on the spread of data points\ndef calculate_zoom_level_1(latitudes_1, longitudes_1):\n    max_lat_1, min_lat_1 = np.max(latitudes_1), np.min(latitudes_1)\n    max_long_1, min_long_1 = np.max(longitudes_1), np.min(longitudes_1)\n    lat_diff_1 = max_lat_1 - min_lat_1\n    long_diff_1 = max_long_1 - min_long_1\n    max_diff_1 = max(lat_diff_1, long_diff_1)\n    \n    if max_diff_1 &lt; 0.01:\n        return 15\n    elif max_diff_1 &lt; 0.1:\n        return 12\n    elif max_diff_1 &lt; 1:\n        return 10\n    elif max_diff_1 &lt; 10:\n        return 8\n    else:\n        return 6\n\n# Calculate zoom level (but we will manually adjust it for more zoom)\nzoom_level_1 = calculate_zoom_level_1(combined_data_1['lat'], combined_data_1['long'])\n\n# Manually adjust zoom level for a more zoomed-in view\nzoom_level_1 = zoom_level_1 * 0.95  # Increase the zoom factor\n\n# Set Mapbox access token\npx.set_mapbox_access_token(\"pk.eyJ1IjoiaXNmYXJiYXNldCIsImEiOiJjbHdiOWVtY2IwbGxsMmtraHZoYnB1YTMwIn0.10XSE1rNVsmXSnFmYYa0Cw\")\n\n# Create the Plotly scatter_mapbox map with enhanced aesthetics and detailed map layers\nmap_fig_1 = px.scatter_mapbox(combined_data_1, lon='long', lat='lat', color='Tmax_Summer',\n                            hover_data={'Tmax_Summer': ':.2f', 'lat': ':.2f', 'long': ':.2f', 'year': True}, size='Tmax_Summer',\n                            labels={'Tmax_Summer': 'max temp', 'lat': 'latitude', 'long': 'longitude'},\n                            animation_frame='year', title='Geospatial Distribution of Maximum Temperature Over Time',\n                            color_continuous_scale=px.colors.sequential.Sunsetdark, size_max=15, zoom=zoom_level_1,\n                            center={\"lat\": center_lat_1, \"lon\": center_long_1}\n                            )\n\n# Update the layout for better aesthetics and visibility of state lines\nmap_fig_1.update_layout(\n    mapbox_style=\"carto-positron\",  # Change the map style to show more details\n    mapbox=dict(\n        center=dict(lat=center_lat_1, lon=center_long_1),\n        zoom=zoom_level_1,  # Adjusted zoom level\n    ),\n    title_font=dict(size=18, family='Arial, sans-serif'),  \n    title_x=0.5,\n    coloraxis_colorbar=dict(\n        title=\"Maximum Temperature(¬∞C)\",\n        title_side=\"right\",  # Align the title horizontally with the colorbar\n        title_font=dict(size=14)  # Adjust the font size as needed\n    ),\n    autosize=True,\n    width=750,  # Increase the width of the map\n    height=700   # Increase the height of the map\n)\n\n\n                        \n                                            \nThis geospatial visualization highlights the maximum temperatures reached within a year across the Southeastern National Parks in Utah. The timeline spans from 1980 to 2024. The animation over the years shows the geographical spread and varying intensity of the highest temperatures in the region.\n\n\n\n\nSummer Heat: On the Rise?\n\n\nCode\nimport pandas as pd\nimport plotly.express as px\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport seaborn as sns\n\n# Load the cleaned datasets\nhistoric_data_1 = pd.read_csv('./data/clean-data/historic_data_cleaned.csv')\nnearterm_data_1 = pd.read_csv('./data/clean-data/nearterm_data_cleaned.csv')\n\n# Combine datasets for some visualizations\ncombined_data_1 = pd.concat([historic_data_1, nearterm_data_1])\n\n# Extracting the relevant column for analysis\nhistoric_tmax_data = historic_data_1[['year', 'Tmax_Summer']]\nnearterm_tmax_data = nearterm_data_1[['year', 'Tmax_Summer']]\n\n# Merging both datasets for a comprehensive analysis\ncombined_tmax_data = pd.concat([historic_tmax_data, nearterm_tmax_data])\n\n# Aggregating the data by year using the mean\ncombined_tmax_data_aggregated = combined_tmax_data.groupby('year').mean().reset_index()\n\n# Setting the style of the plot\nsns.set_theme(style=\"whitegrid\")\n\n# Plotting the Tmax_Summer over the years with enhancements and a trendline\nplt.figure(figsize=(16, 9))\nsns.lineplot(data=combined_tmax_data_aggregated, x='year', y='Tmax_Summer', marker='o', color='maroon', linewidth=2.5, label='Maximum Summer Temperature')\nsns.regplot(data=combined_tmax_data_aggregated, x='year', y='Tmax_Summer', scatter=False, color='red', ci=None, line_kws={\"linewidth\":2.5, \"linestyle\":\"--\"}, label='Trendline')\n\n# Adding titles and labels with enhanced aesthetics\nplt.title('Maximum Temperature Trend\\n in Southeastern Utah', fontsize=32)\nplt.xlabel('Year', fontsize=25, weight='bold')\nplt.ylabel('Maximum Temperature (¬∞C)', fontsize=25, weight='bold')\n\n# Setting the x-axis range from 1980 to 2024\n_ = plt.xlim(1980, 2024)\n\n# Adding a grid with customized appearance\n_ = plt.grid(True, linestyle='--', linewidth=0.7, alpha=0.7)\n\n# Enhancing the tick labels for better readability\n_ = plt.xticks(fontsize=20)\n_ = plt.yticks(fontsize=20)\n\n# Adding a light background color to the plot area\nplt.gca().set_facecolor('#f7f7f7')\n\n# Removing the top and right spines for a cleaner look\nsns.despine()\n\n# Adding legend\n_ = plt.legend(fontsize=20)\n\n# Display the plot\nplt.show()\n\n\n\n\n\nThe chart above illustrates the trend in maximum temperatures from 1980 up until the current year. The visualization suggests an overall increase, indicating a trend of rising temperatures in the region.\n\n\n\n\n\n\nNext up:\nThis raises curiosity to further study the trends in the Summer temperatures of the past and if they are likely to increase in the future ‚û°Ô∏è",
    "crumbs": [
      "Chapter 0Ô∏è‚É£",
      "Introduction"
    ]
  },
  {
    "objectID": "index.html#subtitle",
    "href": "index.html#subtitle",
    "title": "Introduction",
    "section": "",
    "text": "More text\n\nü•µ\n\n\n\n\n\nCode\nimport pandas as pd\nimport plotly.express as px\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport seaborn as sns\n\n# Load the cleaned datasets\nhistoric_data_1 = pd.read_csv('./data/clean-data/historic_data_cleaned.csv')\nnearterm_data_1 = pd.read_csv('./data/clean-data/nearterm_data_cleaned.csv')\n\n# Combine datasets for some visualizations\ncombined_data_1 = pd.concat([historic_data_1, nearterm_data_1])\n\n# Calculate the center of the map\ncenter_lat_1 = combined_data_1['lat'].mean()\ncenter_long_1 = combined_data_1['long'].mean()\n\n# Function to calculate an appropriate zoom level based on the spread of data points\ndef calculate_zoom_level_1(latitudes_1, longitudes_1):\n    max_lat_1, min_lat_1 = np.max(latitudes_1), np.min(latitudes_1)\n    max_long_1, min_long_1 = np.max(longitudes_1), np.min(longitudes_1)\n    lat_diff_1 = max_lat_1 - min_lat_1\n    long_diff_1 = max_long_1 - min_long_1\n    max_diff_1 = max(lat_diff_1, long_diff_1)\n    \n    if max_diff_1 &lt; 0.01:\n        return 15\n    elif max_diff_1 &lt; 0.1:\n        return 12\n    elif max_diff_1 &lt; 1:\n        return 10\n    elif max_diff_1 &lt; 10:\n        return 8\n    else:\n        return 6\n\n# Calculate zoom level (but we will manually adjust it for more zoom)\nzoom_level_1 = calculate_zoom_level_1(combined_data_1['lat'], combined_data_1['long'])\n\n# Manually adjust zoom level for a more zoomed-in view\nzoom_level_1 = zoom_level_1 * 0.95  # Increase the zoom factor\n\n# Set Mapbox access token\npx.set_mapbox_access_token(\"pk.eyJ1IjoiaXNmYXJiYXNldCIsImEiOiJjbHdiOWVtY2IwbGxsMmtraHZoYnB1YTMwIn0.10XSE1rNVsmXSnFmYYa0Cw\")\n\n# Create the Plotly scatter_mapbox map with enhanced aesthetics and detailed map layers\nmap_fig_1 = px.scatter_mapbox(combined_data_1, lon='long', lat='lat', color='Tmax_Summer',\n                            hover_data={'Tmax_Summer': ':.2f', 'lat': ':.2f', 'long': ':.2f', 'year': True}, size='Tmax_Summer',\n                            labels={'Tmax_Summer': 'max temp', 'lat': 'latitude', 'long': 'longitude'},\n                            animation_frame='year', title='Geospatial Distribution of Maximum Temperature Over Time',\n                            color_continuous_scale=px.colors.sequential.Sunsetdark, size_max=15, zoom=zoom_level_1,\n                            center={\"lat\": center_lat_1, \"lon\": center_long_1}\n                            )\n\n# Update the layout for better aesthetics and visibility of state lines\nmap_fig_1.update_layout(\n    mapbox_style=\"carto-positron\",  # Change the map style to show more details\n    mapbox=dict(\n        center=dict(lat=center_lat_1, lon=center_long_1),\n        zoom=zoom_level_1,  # Adjusted zoom level\n    ),\n    title_font=dict(size=18, family='Arial, sans-serif'),  \n    title_x=0.5,\n    coloraxis_colorbar=dict(\n        title=\"Maximum Temperature(¬∞C)\",\n        title_side=\"right\",  # Align the title horizontally with the colorbar\n        title_font=dict(size=14)  # Adjust the font size as needed\n    ),\n    autosize=True,\n    width=750,  # Increase the width of the map\n    height=700   # Increase the height of the map\n)\n\n\n                        \n                                            \nplace description here\n\n\nCode\n# Extracting the relevant column for analysis\nhistoric_tmax_data = historic_data_1[['year', 'Tmax_Summer']]\nnearterm_tmax_data = nearterm_data_1[['year', 'Tmax_Summer']]\n\n# Merging both datasets for a comprehensive analysis\ncombined_tmax_data = pd.concat([historic_tmax_data, nearterm_tmax_data])\n\n# Aggregating the data by year using the mean\ncombined_tmax_data_aggregated = combined_tmax_data.groupby('year').mean().reset_index()\n\n# Setting the style of the plot\nsns.set_theme(style=\"whitegrid\")\n\n# Plotting the Tmax_Summer over the years with enhancements and a trendline\nplt.figure(figsize=(16, 9))\nsns.lineplot(data=combined_tmax_data_aggregated, x='year', y='Tmax_Summer', marker='o', color='maroon', linewidth=2.5, label='Maximum Summer Temperature')\nsns.regplot(data=combined_tmax_data_aggregated, x='year', y='Tmax_Summer', scatter=False, color='red', ci=None, line_kws={\"linewidth\":2.5, \"linestyle\":\"--\"}, label='Trendline')\n\n# Adding titles and labels with enhanced aesthetics\nplt.title('Maximum Temperature Trend\\n in Southeastern Utah', fontsize=32)\nplt.xlabel('Year', fontsize=25, weight='bold')\nplt.ylabel('Maximum Temperature (¬∞C)', fontsize=25, weight='bold')\n\n# Setting the x-axis range from 1980 to 2024\n_ = plt.xlim(1980, 2024)\n\n# Adding a grid with customized appearance\n_ = plt.grid(True, linestyle='--', linewidth=0.7, alpha=0.7)\n\n# Enhancing the tick labels for better readability\n_ = plt.xticks(fontsize=20)\n_ = plt.yticks(fontsize=20)\n\n# Adding a light background color to the plot area\nplt.gca().set_facecolor('#f7f7f7')\n\n# Removing the top and right spines for a cleaner look\nsns.despine()\n\n# Adding legend\n_ = plt.legend(fontsize=20)\n\n# Display the plot\nplt.show()\n\n\n\n\n\nplace description here",
    "crumbs": [
      "Chapter 0Ô∏è‚É£",
      "Introduction"
    ]
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site"
  },
  {
    "objectID": "trend.html",
    "href": "trend.html",
    "title": "Trend Analysis",
    "section": "",
    "text": "Text here\n\n\nCode\nlibrary(reticulate)\n\nuse_condaenv(\"base\", required = TRUE)\n\n\n\n\nMore text\n\n\n\n\nCode\nimport pandas as pd\nimport plotly.express as px\nimport plotly.graph_objects as go\nimport numpy as np\nfrom sklearn.linear_model import LinearRegression\n\n# Load the cleaned datasets\nhistoric_data = pd.read_csv('./data/clean-data/historic_data_cleaned.csv')\nnearterm_data = pd.read_csv('./data/clean-data/nearterm_data_cleaned.csv')\n\n# Combine datasets for some visualizations\ncombined_data = pd.concat([historic_data, nearterm_data])\n\n# Prepare data for linear regression\ncombined_precip = combined_data.dropna(subset=['PPT_Annual'])\nX_precip = combined_precip[['year']].values\ny_precip = combined_precip['PPT_Annual'].values\n\n# Prepare data for linear regression\ncombined_temp = combined_data.dropna(subset=['T_Annual'])\nX_temp = combined_temp[['year']].values\ny_temp = combined_temp['T_Annual'].values\n\n# Aggregate data by year for temperature and precipitation\naggregated_temp = combined_temp.groupby('year').mean().reset_index()\naggregated_precip = combined_precip.groupby('year').mean().reset_index()\n\n# Linear regression analysis for aggregated temperature data\nX_temp_agg = aggregated_temp[['year']].values\ny_temp_agg = aggregated_temp['T_Annual'].values\nmodel_temp_agg = LinearRegression().fit(X_temp_agg, y_temp_agg)\ntrend_temp_agg = model_temp_agg.predict(X_temp_agg)\nslope_temp_agg = model_temp_agg.coef_[0]\nintercept_temp_agg = model_temp_agg.intercept_\n\n# Create the figure for temperature trend\nfig_temp = go.Figure(data=[\n    go.Scatter(\n        x=aggregated_temp['year'], \n        y=aggregated_temp['T_Annual'],\n        mode='markers+lines',\n        name='Observed',\n        hovertemplate='Year: %{x}&lt;br&gt;Avg Temp: %{y:.2f}¬∞C'\n    ),\n    go.Scatter(\n        x=aggregated_temp['year'], \n        y=trend_temp_agg,\n        mode='lines',\n        name='Trend',\n        line=dict(color='red'),\n        hovertemplate='Year: %{x}&lt;br&gt;Trend: %{y:.2f}¬∞C'\n    )\n])\n\n# Update layout for temperature trend\nfig_temp.update_layout(\n    title='Trend Analysis: Average Annual Temperature in Utah (1980-2024)',\n    xaxis_title='Year',\n    yaxis_title='Average Temperature (¬∞C)',\n    legend_title='',\n    template='plotly_white'\n)\n\n\n                        \n                                            \nplace description here\n\n\nCode\n# Linear regression analysis for aggregated precipitation data with the full range of years\nall_years = pd.DataFrame({'year': np.arange(aggregated_precip['year'].min(), aggregated_precip['year'].max() + 1)})\naggregated_precip_full = pd.merge(all_years, aggregated_precip, on='year', how='left')\n\nX_precip_agg_full = aggregated_precip_full[['year']].values\ny_precip_agg_full = aggregated_precip_full['PPT_Annual'].values\nmodel_precip_agg_full = LinearRegression().fit(X_precip_agg_full[~np.isnan(y_precip_agg_full)], \n                                               y_precip_agg_full[~np.isnan(y_precip_agg_full)])\ntrend_precip_agg_full = model_precip_agg_full.predict(X_precip_agg_full)\n\n# Create the figure for precipitation trend with line plot\nfig_precip = go.Figure(data=[\n    go.Scatter(\n        x=aggregated_precip_full['year'], \n        y=aggregated_precip_full['PPT_Annual'],\n        mode='markers+lines',\n        name='Observed',\n        line=dict(color='skyblue'),\n        hovertemplate='Year: %{x}&lt;br&gt;Total Precip: %{y:.2f} inches'\n    ),\n    go.Scatter(\n        x=aggregated_precip_full['year'], \n        y=trend_precip_agg_full,\n        mode='lines',\n        name='Trend',\n        line=dict(color='red'),\n        hovertemplate='Year: %{x}&lt;br&gt;Trend: %{y:.2f} inches'\n    )\n])\n\n# Update layout for precipitation trend\nfig_precip.update_layout(\n    title='Trend Analysis: Total Annual Precipitation in Utah (1980-2024)',\n    xaxis_title='Year',\n    yaxis_title='Total Precipitation (inches)',\n    legend_title='',\n    template='plotly_white'\n)\n\n\n                        \n                                            \nplace description here\n\n\nHi my name is Isfar",
    "crumbs": [
      "What's trending üìä",
      "Trend Analysis"
    ]
  },
  {
    "objectID": "trend.html#subtitle",
    "href": "trend.html#subtitle",
    "title": "Trend Analysis",
    "section": "",
    "text": "More text\n\n\n\n\nCode\nimport pandas as pd\nimport plotly.express as px\nimport plotly.graph_objects as go\nimport numpy as np\nfrom sklearn.linear_model import LinearRegression\n\n# Load the cleaned datasets\nhistoric_data = pd.read_csv('./data/clean-data/historic_data_cleaned.csv')\nnearterm_data = pd.read_csv('./data/clean-data/nearterm_data_cleaned.csv')\n\n# Combine datasets for some visualizations\ncombined_data = pd.concat([historic_data, nearterm_data])\n\n# Prepare data for linear regression\ncombined_precip = combined_data.dropna(subset=['PPT_Annual'])\nX_precip = combined_precip[['year']].values\ny_precip = combined_precip['PPT_Annual'].values\n\n# Prepare data for linear regression\ncombined_temp = combined_data.dropna(subset=['T_Annual'])\nX_temp = combined_temp[['year']].values\ny_temp = combined_temp['T_Annual'].values\n\n# Aggregate data by year for temperature and precipitation\naggregated_temp = combined_temp.groupby('year').mean().reset_index()\naggregated_precip = combined_precip.groupby('year').mean().reset_index()\n\n# Linear regression analysis for aggregated temperature data\nX_temp_agg = aggregated_temp[['year']].values\ny_temp_agg = aggregated_temp['T_Annual'].values\nmodel_temp_agg = LinearRegression().fit(X_temp_agg, y_temp_agg)\ntrend_temp_agg = model_temp_agg.predict(X_temp_agg)\nslope_temp_agg = model_temp_agg.coef_[0]\nintercept_temp_agg = model_temp_agg.intercept_\n\n# Create the figure for temperature trend\nfig_temp = go.Figure(data=[\n    go.Scatter(\n        x=aggregated_temp['year'], \n        y=aggregated_temp['T_Annual'],\n        mode='markers+lines',\n        name='Observed',\n        hovertemplate='Year: %{x}&lt;br&gt;Avg Temp: %{y:.2f}¬∞C'\n    ),\n    go.Scatter(\n        x=aggregated_temp['year'], \n        y=trend_temp_agg,\n        mode='lines',\n        name='Trend',\n        line=dict(color='red'),\n        hovertemplate='Year: %{x}&lt;br&gt;Trend: %{y:.2f}¬∞C'\n    )\n])\n\n# Update layout for temperature trend\nfig_temp.update_layout(\n    title='Trend Analysis: Average Annual Temperature in Utah (1980-2024)',\n    xaxis_title='Year',\n    yaxis_title='Average Temperature (¬∞C)',\n    legend_title='',\n    template='plotly_white'\n)\n\n\n                        \n                                            \nplace description here\n\n\nCode\n# Linear regression analysis for aggregated precipitation data with the full range of years\nall_years = pd.DataFrame({'year': np.arange(aggregated_precip['year'].min(), aggregated_precip['year'].max() + 1)})\naggregated_precip_full = pd.merge(all_years, aggregated_precip, on='year', how='left')\n\nX_precip_agg_full = aggregated_precip_full[['year']].values\ny_precip_agg_full = aggregated_precip_full['PPT_Annual'].values\nmodel_precip_agg_full = LinearRegression().fit(X_precip_agg_full[~np.isnan(y_precip_agg_full)], \n                                               y_precip_agg_full[~np.isnan(y_precip_agg_full)])\ntrend_precip_agg_full = model_precip_agg_full.predict(X_precip_agg_full)\n\n# Create the figure for precipitation trend with line plot\nfig_precip = go.Figure(data=[\n    go.Scatter(\n        x=aggregated_precip_full['year'], \n        y=aggregated_precip_full['PPT_Annual'],\n        mode='markers+lines',\n        name='Observed',\n        line=dict(color='skyblue'),\n        hovertemplate='Year: %{x}&lt;br&gt;Total Precip: %{y:.2f} inches'\n    ),\n    go.Scatter(\n        x=aggregated_precip_full['year'], \n        y=trend_precip_agg_full,\n        mode='lines',\n        name='Trend',\n        line=dict(color='red'),\n        hovertemplate='Year: %{x}&lt;br&gt;Trend: %{y:.2f} inches'\n    )\n])\n\n# Update layout for precipitation trend\nfig_precip.update_layout(\n    title='Trend Analysis: Total Annual Precipitation in Utah (1980-2024)',\n    xaxis_title='Year',\n    yaxis_title='Total Precipitation (inches)',\n    legend_title='',\n    template='plotly_white'\n)\n\n\n                        \n                                            \nplace description here\n\n\nHi my name is Isfar",
    "crumbs": [
      "What's trending üìä",
      "Trend Analysis"
    ]
  },
  {
    "objectID": "treecanopy.html",
    "href": "treecanopy.html",
    "title": "Treecanopy Analysis",
    "section": "",
    "text": "Text here\n\n\nCode\nlibrary(reticulate)\n\nuse_condaenv(\"base\", required = TRUE)\n\n\n\n\nMore text\n\n\n\n\nCode\nimport pandas as pd\nimport plotly.express as px\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Load the cleaned datasets\nhistoric_data = pd.read_csv('./data/clean-data/historic_data_cleaned.csv')\nnearterm_data = pd.read_csv('./data/clean-data/nearterm_data_cleaned.csv')\n\n# Combine datasets for some visualizations\ncombined_data = pd.concat([historic_data, nearterm_data])\n\n# Calculate the center of the map\ncenter_lat = combined_data['lat'].mean()\ncenter_long = combined_data['long'].mean()\n\n# Function to calculate an appropriate zoom level based on the spread of data points\ndef calculate_zoom_level(latitudes, longitudes):\n    max_lat, min_lat = np.max(latitudes), np.min(latitudes)\n    max_long, min_long = np.max(longitudes), np.min(longitudes)\n    lat_diff = max_lat - min_lat\n    long_diff = max_long - min_long\n    max_diff = max(lat_diff, long_diff)\n    \n    if max_diff &lt; 0.01:\n        return 15\n    elif max_diff &lt; 0.1:\n        return 12\n    elif max_diff &lt; 1:\n        return 10\n    elif max_diff &lt; 10:\n        return 8\n    else:\n        return 6\n\n# Calculate zoom level (but we will manually adjust it for more zoom)\nzoom_level = calculate_zoom_level(combined_data['lat'], combined_data['long'])\n\n# Manually adjust zoom level for a more zoomed-in view\nzoom_level = zoom_level * 0.95  # Increase the zoom factor\n\n# Create the Plotly scatter_mapbox map with enhanced aesthetics and detailed map layers\nmap_fig = px.scatter_mapbox(combined_data, lon='long', lat='lat', color='treecanopy',\n                            hover_data={'treecanopy': ':.2f', 'lat': ':.2f', 'long': ':.2f', 'year': True}, size='treecanopy',\n                            labels={'treecanopy': 'tree canopy', 'lat': 'latitude', 'long': 'longitude'},\n                            animation_frame='year', title='Geospatial Distribution of Tree Canopy Over Time',\n                            color_continuous_scale=px.colors.sequential.Sunsetdark, size_max=15, zoom=zoom_level,\n                            center={\"lat\": center_lat, \"lon\": center_long})\n\n# Update the layout for better aesthetics and visibility of state lines\nmap_fig.update_layout(\n    mapbox_style=\"carto-positron\",  # Change the map style to show more details\n    mapbox=dict(\n        center=dict(lat=center_lat, lon=center_long),\n        zoom=zoom_level,  # Adjusted zoom level\n    ),\n    title_font=dict(size=18, family='Arial, sans-serif'),  \n    title_x=0.5,\n    coloraxis_colorbar=dict(\n        title=\"Tree Canopy (%)\",\n        title_side=\"right\",  # Align the title horizontally with the colorbar\n        title_font=dict(size=14)  # Adjust the font size as needed\n    ),\n    autosize=True,\n    width=800,  # Increase the width of the map\n    height=700   # Increase the height of the map\n)\n\n\n                        \n                                            \nplace description here\n\n\nHi my name is Isfar",
    "crumbs": [
      "Looking into treecanopy üå≥",
      "Treecanopy Analysis"
    ]
  },
  {
    "objectID": "treecanopy.html#subtitle",
    "href": "treecanopy.html#subtitle",
    "title": "Treecanopy Analysis",
    "section": "",
    "text": "More text\n\n\n\n\nCode\nimport pandas as pd\nimport plotly.express as px\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Load the cleaned datasets\nhistoric_data = pd.read_csv('./data/clean-data/historic_data_cleaned.csv')\nnearterm_data = pd.read_csv('./data/clean-data/nearterm_data_cleaned.csv')\n\n# Combine datasets for some visualizations\ncombined_data = pd.concat([historic_data, nearterm_data])\n\n# Calculate the center of the map\ncenter_lat = combined_data['lat'].mean()\ncenter_long = combined_data['long'].mean()\n\n# Function to calculate an appropriate zoom level based on the spread of data points\ndef calculate_zoom_level(latitudes, longitudes):\n    max_lat, min_lat = np.max(latitudes), np.min(latitudes)\n    max_long, min_long = np.max(longitudes), np.min(longitudes)\n    lat_diff = max_lat - min_lat\n    long_diff = max_long - min_long\n    max_diff = max(lat_diff, long_diff)\n    \n    if max_diff &lt; 0.01:\n        return 15\n    elif max_diff &lt; 0.1:\n        return 12\n    elif max_diff &lt; 1:\n        return 10\n    elif max_diff &lt; 10:\n        return 8\n    else:\n        return 6\n\n# Calculate zoom level (but we will manually adjust it for more zoom)\nzoom_level = calculate_zoom_level(combined_data['lat'], combined_data['long'])\n\n# Manually adjust zoom level for a more zoomed-in view\nzoom_level = zoom_level * 0.95  # Increase the zoom factor\n\n# Create the Plotly scatter_mapbox map with enhanced aesthetics and detailed map layers\nmap_fig = px.scatter_mapbox(combined_data, lon='long', lat='lat', color='treecanopy',\n                            hover_data={'treecanopy': ':.2f', 'lat': ':.2f', 'long': ':.2f', 'year': True}, size='treecanopy',\n                            labels={'treecanopy': 'tree canopy', 'lat': 'latitude', 'long': 'longitude'},\n                            animation_frame='year', title='Geospatial Distribution of Tree Canopy Over Time',\n                            color_continuous_scale=px.colors.sequential.Sunsetdark, size_max=15, zoom=zoom_level,\n                            center={\"lat\": center_lat, \"lon\": center_long})\n\n# Update the layout for better aesthetics and visibility of state lines\nmap_fig.update_layout(\n    mapbox_style=\"carto-positron\",  # Change the map style to show more details\n    mapbox=dict(\n        center=dict(lat=center_lat, lon=center_long),\n        zoom=zoom_level,  # Adjusted zoom level\n    ),\n    title_font=dict(size=18, family='Arial, sans-serif'),  \n    title_x=0.5,\n    coloraxis_colorbar=dict(\n        title=\"Tree Canopy (%)\",\n        title_side=\"right\",  # Align the title horizontally with the colorbar\n        title_font=dict(size=14)  # Adjust the font size as needed\n    ),\n    autosize=True,\n    width=800,  # Increase the width of the map\n    height=700   # Increase the height of the map\n)\n\n\n                        \n                                            \nplace description here\n\n\nHi my name is Isfar",
    "crumbs": [
      "Looking into treecanopy üå≥",
      "Treecanopy Analysis"
    ]
  },
  {
    "objectID": "pages/treecanopy/treecanopy.html",
    "href": "pages/treecanopy/treecanopy.html",
    "title": "Treecanopy Coverage",
    "section": "",
    "text": "Text here\n\n\nCode\nlibrary(reticulate)\n\nuse_condaenv(\"base\", required = TRUE)\n\n\n\n\nMore text\n\n\n\n\nCode\nimport pandas as pd\nimport plotly.express as px\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Load the cleaned datasets\nhistoric_data = pd.read_csv('../../data/clean-data/historic_data_cleaned.csv')\nnearterm_data = pd.read_csv('../../data/clean-data/nearterm_data_cleaned.csv')\n\n# Combine datasets for some visualizations\ncombined_data = pd.concat([historic_data, nearterm_data])\n\n# Calculate the center of the map\ncenter_lat = combined_data['lat'].mean()\ncenter_long = combined_data['long'].mean()\n\n# Function to calculate an appropriate zoom level based on the spread of data points\ndef calculate_zoom_level(latitudes, longitudes):\n    max_lat, min_lat = np.max(latitudes), np.min(latitudes)\n    max_long, min_long = np.max(longitudes), np.min(longitudes)\n    lat_diff = max_lat - min_lat\n    long_diff = max_long - min_long\n    max_diff = max(lat_diff, long_diff)\n    \n    if max_diff &lt; 0.01:\n        return 15\n    elif max_diff &lt; 0.1:\n        return 12\n    elif max_diff &lt; 1:\n        return 10\n    elif max_diff &lt; 10:\n        return 8\n    else:\n        return 6\n\n# Calculate zoom level (but we will manually adjust it for more zoom)\nzoom_level = calculate_zoom_level(combined_data['lat'], combined_data['long'])\n\n# Manually adjust zoom level for a more zoomed-in view\nzoom_level = zoom_level * 0.95  # Increase the zoom factor\n\n# Create the Plotly scatter_mapbox map with enhanced aesthetics and detailed map layers\nmap_fig = px.scatter_mapbox(combined_data, lon='long', lat='lat', color='treecanopy',\n                            hover_data={'treecanopy': ':.2f', 'lat': ':.2f', 'long': ':.2f', 'year': True}, size='treecanopy',\n                            labels={'treecanopy': 'tree canopy', 'lat': 'latitude', 'long': 'longitude'},\n                            animation_frame='year', title='Geospatial Distribution of Tree Canopy Over Time',\n                            color_continuous_scale=px.colors.sequential.Sunsetdark, size_max=15, zoom=zoom_level,\n                            center={\"lat\": center_lat, \"lon\": center_long})\n\n# Update the layout for better aesthetics and visibility of state lines\nmap_fig.update_layout(\n    mapbox_style=\"carto-positron\",  # Change the map style to show more details\n    mapbox=dict(\n        center=dict(lat=center_lat, lon=center_long),\n        zoom=zoom_level,  # Adjusted zoom level\n    ),\n    title_font=dict(size=18, family='Arial, sans-serif'),  \n    title_x=0.5,\n    coloraxis_colorbar=dict(\n        title=\"Tree Canopy (%)\",\n        title_side=\"right\",  # Align the title horizontally with the colorbar\n        title_font=dict(size=14)  # Adjust the font size as needed\n    ),\n    autosize=True,\n    width=800,  # Increase the width of the map\n    height=700   # Increase the height of the map\n)\n\n\n                        \n                                            \nplace description here\n\n\nHi my name is Isfar",
    "crumbs": [
      "2Ô∏è‚É£",
      "Treecanopy Coverage"
    ]
  },
  {
    "objectID": "pages/treecanopy/treecanopy.html#subtitle",
    "href": "pages/treecanopy/treecanopy.html#subtitle",
    "title": "Treecanopy Coverage",
    "section": "",
    "text": "More text\n\n\n\n\nCode\nimport pandas as pd\nimport plotly.express as px\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Load the cleaned datasets\nhistoric_data = pd.read_csv('../../data/clean-data/historic_data_cleaned.csv')\nnearterm_data = pd.read_csv('../../data/clean-data/nearterm_data_cleaned.csv')\n\n# Combine datasets for some visualizations\ncombined_data = pd.concat([historic_data, nearterm_data])\n\n# Calculate the center of the map\ncenter_lat = combined_data['lat'].mean()\ncenter_long = combined_data['long'].mean()\n\n# Function to calculate an appropriate zoom level based on the spread of data points\ndef calculate_zoom_level(latitudes, longitudes):\n    max_lat, min_lat = np.max(latitudes), np.min(latitudes)\n    max_long, min_long = np.max(longitudes), np.min(longitudes)\n    lat_diff = max_lat - min_lat\n    long_diff = max_long - min_long\n    max_diff = max(lat_diff, long_diff)\n    \n    if max_diff &lt; 0.01:\n        return 15\n    elif max_diff &lt; 0.1:\n        return 12\n    elif max_diff &lt; 1:\n        return 10\n    elif max_diff &lt; 10:\n        return 8\n    else:\n        return 6\n\n# Calculate zoom level (but we will manually adjust it for more zoom)\nzoom_level = calculate_zoom_level(combined_data['lat'], combined_data['long'])\n\n# Manually adjust zoom level for a more zoomed-in view\nzoom_level = zoom_level * 0.95  # Increase the zoom factor\n\n# Create the Plotly scatter_mapbox map with enhanced aesthetics and detailed map layers\nmap_fig = px.scatter_mapbox(combined_data, lon='long', lat='lat', color='treecanopy',\n                            hover_data={'treecanopy': ':.2f', 'lat': ':.2f', 'long': ':.2f', 'year': True}, size='treecanopy',\n                            labels={'treecanopy': 'tree canopy', 'lat': 'latitude', 'long': 'longitude'},\n                            animation_frame='year', title='Geospatial Distribution of Tree Canopy Over Time',\n                            color_continuous_scale=px.colors.sequential.Sunsetdark, size_max=15, zoom=zoom_level,\n                            center={\"lat\": center_lat, \"lon\": center_long})\n\n# Update the layout for better aesthetics and visibility of state lines\nmap_fig.update_layout(\n    mapbox_style=\"carto-positron\",  # Change the map style to show more details\n    mapbox=dict(\n        center=dict(lat=center_lat, lon=center_long),\n        zoom=zoom_level,  # Adjusted zoom level\n    ),\n    title_font=dict(size=18, family='Arial, sans-serif'),  \n    title_x=0.5,\n    coloraxis_colorbar=dict(\n        title=\"Tree Canopy (%)\",\n        title_side=\"right\",  # Align the title horizontally with the colorbar\n        title_font=dict(size=14)  # Adjust the font size as needed\n    ),\n    autosize=True,\n    width=800,  # Increase the width of the map\n    height=700   # Increase the height of the map\n)\n\n\n                        \n                                            \nplace description here\n\n\nHi my name is Isfar",
    "crumbs": [
      "2Ô∏è‚É£",
      "Treecanopy Coverage"
    ]
  },
  {
    "objectID": "pages/trend/trend.html",
    "href": "pages/trend/trend.html",
    "title": "Trend Analysis",
    "section": "",
    "text": "Text here\n\n\nCode\nlibrary(reticulate)\n\nuse_condaenv(\"base\", required = TRUE)\n\n\n\n\nMore text\n\n\n\n\nCode\nimport pandas as pd\nimport plotly.express as px\nimport plotly.graph_objects as go\nimport numpy as np\nfrom sklearn.linear_model import LinearRegression\n\n# Load the cleaned datasets\nhistoric_data = pd.read_csv('../../data/clean-data/historic_data_cleaned.csv')\nnearterm_data = pd.read_csv('../../data/clean-data/nearterm_data_cleaned.csv')\n\n# Combine datasets for some visualizations\ncombined_data = pd.concat([historic_data, nearterm_data])\n\n# Prepare data for linear regression\ncombined_precip = combined_data.dropna(subset=['PPT_Annual'])\nX_precip = combined_precip[['year']].values\ny_precip = combined_precip['PPT_Annual'].values\n\n# Prepare data for linear regression\ncombined_temp = combined_data.dropna(subset=['T_Annual'])\nX_temp = combined_temp[['year']].values\ny_temp = combined_temp['T_Annual'].values\n\n# Aggregate data by year for temperature and precipitation\naggregated_temp = combined_temp.groupby('year').mean().reset_index()\naggregated_precip = combined_precip.groupby('year').mean().reset_index()\n\n# Linear regression analysis for aggregated temperature data\nX_temp_agg = aggregated_temp[['year']].values\ny_temp_agg = aggregated_temp['T_Annual'].values\nmodel_temp_agg = LinearRegression().fit(X_temp_agg, y_temp_agg)\ntrend_temp_agg = model_temp_agg.predict(X_temp_agg)\nslope_temp_agg = model_temp_agg.coef_[0]\nintercept_temp_agg = model_temp_agg.intercept_\n\n# Create the figure for temperature trend\nfig_temp = go.Figure(data=[\n    go.Scatter(\n        x=aggregated_temp['year'], \n        y=aggregated_temp['T_Annual'],\n        mode='markers+lines',\n        name='Observed',\n        hovertemplate='Year: %{x}&lt;br&gt;Avg Temp: %{y:.2f}¬∞C'\n    ),\n    go.Scatter(\n        x=aggregated_temp['year'], \n        y=trend_temp_agg,\n        mode='lines',\n        name='Trend',\n        line=dict(color='red'),\n        hovertemplate='Year: %{x}&lt;br&gt;Trend: %{y:.2f}¬∞C'\n    )\n])\n\n# Update layout for temperature trend\nfig_temp.update_layout(\n    title='Trend Analysis: Average Annual Temperature in Utah (1980-2024)',\n    xaxis_title='Year',\n    yaxis_title='Average Temperature (¬∞C)',\n    legend_title='',\n    template='plotly_white'\n)\n\n\n                        \n                                            \nplace description here\n\n\nCode\n# Linear regression analysis for aggregated precipitation data with the full range of years\nall_years = pd.DataFrame({'year': np.arange(aggregated_precip['year'].min(), aggregated_precip['year'].max() + 1)})\naggregated_precip_full = pd.merge(all_years, aggregated_precip, on='year', how='left')\n\nX_precip_agg_full = aggregated_precip_full[['year']].values\ny_precip_agg_full = aggregated_precip_full['PPT_Annual'].values\nmodel_precip_agg_full = LinearRegression().fit(X_precip_agg_full[~np.isnan(y_precip_agg_full)], \n                                               y_precip_agg_full[~np.isnan(y_precip_agg_full)])\ntrend_precip_agg_full = model_precip_agg_full.predict(X_precip_agg_full)\n\n# Create the figure for precipitation trend with line plot\nfig_precip = go.Figure(data=[\n    go.Scatter(\n        x=aggregated_precip_full['year'], \n        y=aggregated_precip_full['PPT_Annual'],\n        mode='markers+lines',\n        name='Observed',\n        line=dict(color='skyblue'),\n        hovertemplate='Year: %{x}&lt;br&gt;Total Precip: %{y:.2f} inches'\n    ),\n    go.Scatter(\n        x=aggregated_precip_full['year'], \n        y=trend_precip_agg_full,\n        mode='lines',\n        name='Trend',\n        line=dict(color='red'),\n        hovertemplate='Year: %{x}&lt;br&gt;Trend: %{y:.2f} inches'\n    )\n])\n\n# Update layout for precipitation trend\nfig_precip.update_layout(\n    title='Trend Analysis: Total Annual Precipitation in Utah (1980-2024)',\n    xaxis_title='Year',\n    yaxis_title='Total Precipitation (inches)',\n    legend_title='',\n    template='plotly_white'\n)\n\n\n                        \n                                            \nplace description here\n\n\nHi my name is Isfar",
    "crumbs": [
      "3Ô∏è‚É£",
      "Trend Analysis"
    ]
  },
  {
    "objectID": "pages/trend/trend.html#subtitle",
    "href": "pages/trend/trend.html#subtitle",
    "title": "Trend Analysis",
    "section": "",
    "text": "More text\n\n\n\n\nCode\nimport pandas as pd\nimport plotly.express as px\nimport plotly.graph_objects as go\nimport numpy as np\nfrom sklearn.linear_model import LinearRegression\n\n# Load the cleaned datasets\nhistoric_data = pd.read_csv('../../data/clean-data/historic_data_cleaned.csv')\nnearterm_data = pd.read_csv('../../data/clean-data/nearterm_data_cleaned.csv')\n\n# Combine datasets for some visualizations\ncombined_data = pd.concat([historic_data, nearterm_data])\n\n# Prepare data for linear regression\ncombined_precip = combined_data.dropna(subset=['PPT_Annual'])\nX_precip = combined_precip[['year']].values\ny_precip = combined_precip['PPT_Annual'].values\n\n# Prepare data for linear regression\ncombined_temp = combined_data.dropna(subset=['T_Annual'])\nX_temp = combined_temp[['year']].values\ny_temp = combined_temp['T_Annual'].values\n\n# Aggregate data by year for temperature and precipitation\naggregated_temp = combined_temp.groupby('year').mean().reset_index()\naggregated_precip = combined_precip.groupby('year').mean().reset_index()\n\n# Linear regression analysis for aggregated temperature data\nX_temp_agg = aggregated_temp[['year']].values\ny_temp_agg = aggregated_temp['T_Annual'].values\nmodel_temp_agg = LinearRegression().fit(X_temp_agg, y_temp_agg)\ntrend_temp_agg = model_temp_agg.predict(X_temp_agg)\nslope_temp_agg = model_temp_agg.coef_[0]\nintercept_temp_agg = model_temp_agg.intercept_\n\n# Create the figure for temperature trend\nfig_temp = go.Figure(data=[\n    go.Scatter(\n        x=aggregated_temp['year'], \n        y=aggregated_temp['T_Annual'],\n        mode='markers+lines',\n        name='Observed',\n        hovertemplate='Year: %{x}&lt;br&gt;Avg Temp: %{y:.2f}¬∞C'\n    ),\n    go.Scatter(\n        x=aggregated_temp['year'], \n        y=trend_temp_agg,\n        mode='lines',\n        name='Trend',\n        line=dict(color='red'),\n        hovertemplate='Year: %{x}&lt;br&gt;Trend: %{y:.2f}¬∞C'\n    )\n])\n\n# Update layout for temperature trend\nfig_temp.update_layout(\n    title='Trend Analysis: Average Annual Temperature in Utah (1980-2024)',\n    xaxis_title='Year',\n    yaxis_title='Average Temperature (¬∞C)',\n    legend_title='',\n    template='plotly_white'\n)\n\n\n                        \n                                            \nplace description here\n\n\nCode\n# Linear regression analysis for aggregated precipitation data with the full range of years\nall_years = pd.DataFrame({'year': np.arange(aggregated_precip['year'].min(), aggregated_precip['year'].max() + 1)})\naggregated_precip_full = pd.merge(all_years, aggregated_precip, on='year', how='left')\n\nX_precip_agg_full = aggregated_precip_full[['year']].values\ny_precip_agg_full = aggregated_precip_full['PPT_Annual'].values\nmodel_precip_agg_full = LinearRegression().fit(X_precip_agg_full[~np.isnan(y_precip_agg_full)], \n                                               y_precip_agg_full[~np.isnan(y_precip_agg_full)])\ntrend_precip_agg_full = model_precip_agg_full.predict(X_precip_agg_full)\n\n# Create the figure for precipitation trend with line plot\nfig_precip = go.Figure(data=[\n    go.Scatter(\n        x=aggregated_precip_full['year'], \n        y=aggregated_precip_full['PPT_Annual'],\n        mode='markers+lines',\n        name='Observed',\n        line=dict(color='skyblue'),\n        hovertemplate='Year: %{x}&lt;br&gt;Total Precip: %{y:.2f} inches'\n    ),\n    go.Scatter(\n        x=aggregated_precip_full['year'], \n        y=trend_precip_agg_full,\n        mode='lines',\n        name='Trend',\n        line=dict(color='red'),\n        hovertemplate='Year: %{x}&lt;br&gt;Trend: %{y:.2f} inches'\n    )\n])\n\n# Update layout for precipitation trend\nfig_precip.update_layout(\n    title='Trend Analysis: Total Annual Precipitation in Utah (1980-2024)',\n    xaxis_title='Year',\n    yaxis_title='Total Precipitation (inches)',\n    legend_title='',\n    template='plotly_white'\n)\n\n\n                        \n                                            \nplace description here\n\n\nHi my name is Isfar",
    "crumbs": [
      "3Ô∏è‚É£",
      "Trend Analysis"
    ]
  },
  {
    "objectID": "pages/soil/soil.html",
    "href": "pages/soil/soil.html",
    "title": "Soil in Summer",
    "section": "",
    "text": "Code\nimport pandas as pd\nimport plotly.express as px\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport pandas as pd\nimport plotly.graph_objects as go\nimport seaborn as sns\n\n\n\n\nCode\n# Load the cleaned datasets\nhistoric_data = pd.read_csv('../../data/clean-data/historic_data_cleaned.csv')\nnearterm_data = pd.read_csv('../../data/clean-data/nearterm_data_cleaned.csv')\n\n# Combine datasets for some visualizations\ncombined_data = pd.concat([historic_data, nearterm_data])\n\n\n\n\nCode\n# Group by year and calculate the average values for Tmax_Summer and VWC_Summer_whole\naverage_data = combined_data.groupby('year').agg({'Tmax_Summer': 'mean', 'VWC_Summer_whole': 'mean'}).reset_index()\n\n# Create the scatter plot to show the relationship between Tmax_Summer and VWC_Summer_whole\nfig = px.scatter(average_data, x='Tmax_Summer', y='VWC_Summer_whole',\n                 trendline='ols',  # Add a trendline\n                 title='Relationship Between Summer Maximum Temperature and Soil Moisture',\n                 labels={'Tmax_Summer': 'Maximum Summer Temperature (¬∞C)', 'VWC_Summer_whole': 'Average Soil Moisture (%)'})\n\n# Update layout for better aesthetics\nfig.update_layout(\n    title_font=dict(size=18, family='Arial, sans-serif'),\n    xaxis_title='Maximum Summer Temperature (¬∞C)',\n    yaxis_title='Average Soil Moisture (%)',\n    width=800,\n    height=600\n)\n\n# Show the plot\nfig.show()\n\n\nUnable to display output for mime type(s): application/vnd.plotly.v1+json\n\n\n\n\nCode\n# Extracting the relevant column for analysis\nhistoric_soil_data = historic_data[['year', 'VWC_Summer_whole']]\nnearterm_soil_data = nearterm_data[['year', 'VWC_Summer_whole']]\n\n# Merging both datasets for a comprehensive analysis\ncombined_soil_data = pd.concat([historic_soil_data, nearterm_soil_data])\n\n# Aggregating the data by year using the mean\ncombined_soil_data_aggregated = combined_soil_data.groupby('year').mean().reset_index()\n\n# Plotting the NonDrySWA in Summer trend over the years\nplt.figure(figsize=(10, 6))\nsns.lineplot(data=combined_soil_data_aggregated, x='year', y='VWC_Summer_whole', marker='o', color='brown')\nplt.title('Soil moisture in Summer Trend')\nplt.xlabel('Year')\nplt.ylabel('NonDrySWA in Summer')\nplt.grid(True)\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\nCode\n# Extracting the relevant column for analysis\nhistoric_soil_data = historic_data[['year', 'DrySoilDays_Summer_whole']]\nnearterm_soil_data = nearterm_data[['year', 'DrySoilDays_Summer_whole']]\n\n# Merging both datasets for a comprehensive analysis\ncombined_soil_data = pd.concat([historic_soil_data, nearterm_soil_data])\n\n# Aggregating the data by year using the mean\ncombined_soil_data_aggregated = combined_soil_data.groupby('year').mean().reset_index()\n\n# Plotting the NonDrySWA in Summer trend over the years\nplt.figure(figsize=(10, 6))\nsns.lineplot(data=combined_soil_data_aggregated, x='year', y='DrySoilDays_Summer_whole', marker='o', color='brown')\nplt.title('Dry soil in Summer Trend')\nplt.xlabel('Year')\nplt.ylabel('NonDrySWA in Summer')\nplt.grid(True)\nplt.show()",
    "crumbs": [
      "2Ô∏è‚É£",
      "Soil in Summer"
    ]
  },
  {
    "objectID": "pages/ppt/ppt.html",
    "href": "pages/ppt/ppt.html",
    "title": "Precipitation",
    "section": "",
    "text": "Code\nimport pandas as pd\nimport plotly.express as px\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport pandas as pd\nimport plotly.graph_objects as go\nimport seaborn as sns\n\n\n\n\nCode\n# Load the cleaned datasets\nhistoric_data = pd.read_csv('../../data/clean-data/historic_data_cleaned.csv')\nnearterm_data = pd.read_csv('../../data/clean-data/nearterm_data_cleaned.csv')\n\n# Combine datasets for some visualizations\ncombined_data = pd.concat([historic_data, nearterm_data])\n\n\n\n\nCode\n# Extracting the relevant column for analysis\nhistoric_ppt_data = historic_data[['year', 'PPT_Summer']]\nnearterm_ppt_data = nearterm_data[['year', 'PPT_Summer']]\n\n# Merging both datasets for a comprehensive analysis\ncombined_ppt_data = pd.concat([historic_ppt_data, nearterm_ppt_data])\n\n# Aggregating the data by year using the mean\ncombined_soil_data_aggregated = combined_ppt_data.groupby('year').mean().reset_index()\n\n# Plotting the PPT_Summer over the years\nplt.figure(figsize=(10, 6))\nsns.lineplot(data=combined_ppt_data, x='year', y='PPT_Summer', marker='o', color='cyan')\nplt.title('Summer Precipitation Trend')\nplt.xlabel('Year')\nplt.ylabel('Summer Precipitation (inches)')\nplt.grid(True)\nplt.show()",
    "crumbs": [
      "4Ô∏è‚É£",
      "Precipitation"
    ]
  },
  {
    "objectID": "pages/evaporation/evap.html",
    "href": "pages/evaporation/evap.html",
    "title": "Evaporation",
    "section": "",
    "text": "Code\nimport pandas as pd\nimport plotly.express as px\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport pandas as pd\nimport plotly.graph_objects as go\nimport seaborn as sns\n\n\n\n\nCode\n# Load the cleaned datasets\nhistoric_data = pd.read_csv('../../data/clean-data/historic_data_cleaned.csv')\nnearterm_data = pd.read_csv('../../data/clean-data/nearterm_data_cleaned.csv')\n\n# Combine datasets for some visualizations\ncombined_data = pd.concat([historic_data, nearterm_data])\n\n\n\n\nCode\n# Extracting the relevant column for analysis\nhistoric_evap_data = historic_data[['year', 'Evap_Summer']]\nnearterm_evap_data = nearterm_data[['year', 'Evap_Summer']]\n\n# Merging both datasets for a comprehensive analysis\ncombined_evap_data = pd.concat([historic_evap_data, nearterm_evap_data])\n\n# Aggregating the data by year using the mean\ncombined_evap_data_aggregated = combined_evap_data.groupby('year').mean().reset_index()\n\n# Plotting the Evaporation in Summer trend over the years\nplt.figure(figsize=(10, 6))\nsns.lineplot(data=combined_evap_data_aggregated, x='year', y='Evap_Summer', marker='o', color='orange')\nplt.title('Evaporation in Summer Trend')\nplt.xlabel('Year')\nplt.ylabel('Evaporation in Summer')\nplt.grid(True)\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\nCode\n# Extracting the relevant column for analysis\nhistoric_dry_stress_data = historic_data[['year', 'ExtremeShortTermDryStress_Summer_whole']]\nnearterm_dry_stress_data = nearterm_data[['year', 'ExtremeShortTermDryStress_Summer_whole']]\n\n# Merging both datasets for a comprehensive analysis\ncombined_dry_stress_data = pd.concat([historic_dry_stress_data, nearterm_dry_stress_data])\n\n# Aggregating the data by year using the mean\ncombined_dry_stress_data_aggregated = combined_dry_stress_data.groupby('year').mean().reset_index()\n\n# Plotting the Extreme Short Term Dry Stress in Summer trend over the years\nplt.figure(figsize=(10, 6))\nsns.lineplot(data=combined_dry_stress_data_aggregated, x='year', y='ExtremeShortTermDryStress_Summer_whole', marker='o', color='red')\nplt.title('Extreme Short Term Dry Stress in Summer Trend')\nplt.xlabel('Year')\nplt.ylabel('Extreme Short Term Dry Stress in Summer')\nplt.grid(True)\nplt.show()",
    "crumbs": [
      "3Ô∏è‚É£",
      "Evaporation"
    ]
  },
  {
    "objectID": "soil.html",
    "href": "soil.html",
    "title": "Soil",
    "section": "",
    "text": "Summer temperatures are on the rise, so what does this mean for soil health? Does warmer weather dry up soil moisture levels? Let‚Äôs see what the trend suggests.\n\n\nCode\nlibrary(reticulate)\n\nuse_condaenv(\"base\", required = TRUE)\n\n\n\nHotter Summers, Drier Soils?\n\n\nCode\nimport pandas as pd\nimport plotly.express as px\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport pandas as pd\nimport plotly.graph_objects as go\nimport seaborn as sns\nfrom sklearn.linear_model import LinearRegression\n\n# Load the cleaned datasets\nhistoric_data = pd.read_csv('./data/clean-data/historic_data_cleaned.csv')\nnearterm_data = pd.read_csv('./data/clean-data/nearterm_data_cleaned.csv')\n\n# Combine datasets for some visualizations\ncombined_data = pd.concat([historic_data, nearterm_data])\n\n# Group by year and calculate the average values for Tmax_Summer and VWC_Summer_whole\naverage_data = combined_data.groupby('year').agg({'Tmax_Summer': 'mean', 'VWC_Summer_whole': 'mean'}).reset_index()\n\n# Create the scatter plot to show the relationship between Tmax_Summer and VWC_Summer_whole\nfig = px.scatter(average_data, x='Tmax_Summer', y='VWC_Summer_whole',\n                 trendline='ols',  # Add a trendline\n                 title='Relationship Between Summer Maximum Temperature and Soil Moisture',\n                 labels={'Tmax_Summer': 'Maximum Summer Temperature (¬∞C)', 'VWC_Summer_whole': 'Average Soil Moisture (%)'})\n\n# Update layout for better aesthetics\nfig.update_layout(\n    title_font=dict(size=18, family='Arial, sans-serif'),\n    xaxis_title='Maximum Summer Temperature (¬∞C)',\n    yaxis_title='Average Soil Moisture (%)',\n    width=800,\n    height=600\n)\n\n\n                        \n                                            \nThe scatter plot explores the relationship between maximum summer temperatures and average soil moisture. The trend line shows a slight negative correlation, suggesting that higher temperatures are associated with lower soil moisture levels.\n\n\n\n\nMoisture Matters\n\n\nCode\nimport pandas as pd\nimport plotly.express as px\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport pandas as pd\nimport plotly.graph_objects as go\nimport seaborn as sns\nfrom sklearn.linear_model import LinearRegression\n\n# Load the cleaned datasets\nhistoric_data = pd.read_csv('./data/clean-data/historic_data_cleaned.csv')\nnearterm_data = pd.read_csv('./data/clean-data/nearterm_data_cleaned.csv')\n\n# Extracting the relevant column for VWC_Summer_whole analysis\nhistoric_soil_data_vwc = historic_data[['year', 'VWC_Summer_whole']]\nnearterm_soil_data_vwc = nearterm_data[['year', 'VWC_Summer_whole']]\ncombined_soil_data_vwc = pd.concat([historic_soil_data_vwc, nearterm_soil_data_vwc])\ncombined_soil_data_vwc_aggregated = combined_soil_data_vwc.groupby('year').mean().reset_index()\n\n\n# Function to calculate trendline\ndef calculate_trendline(x, y):\n    model = LinearRegression()\n    x_reshaped = np.array(x).reshape(-1, 1)\n    model.fit(x_reshaped, y)\n    trend = model.predict(x_reshaped)\n    return trend\n\n# Calculate trendline for VWC_Summer_whole\nvwc_trend = calculate_trendline(combined_soil_data_vwc_aggregated['year'], combined_soil_data_vwc_aggregated['VWC_Summer_whole'])\n\n# Determine the y-axis range to better show changes in moisture levels\ny_min = combined_soil_data_vwc_aggregated['VWC_Summer_whole'].min() - 0.005\ny_max = combined_soil_data_vwc_aggregated['VWC_Summer_whole'].max() + 0.005\n\n# Create the first area chart for VWC_Summer_whole with trendline\nfig1 = go.Figure(\n    data=[\n        go.Scatter(\n            x=combined_soil_data_vwc_aggregated['year'],\n            y=combined_soil_data_vwc_aggregated['VWC_Summer_whole'],\n            fill='tozeroy',\n            name='Soil Moisture in Summer',\n            mode='none',\n            fillcolor='#003c54'\n        ),\n        go.Scatter(\n            x=combined_soil_data_vwc_aggregated['year'],\n            y=vwc_trend,\n            mode='lines',\n            name='Trendline',\n            line=dict(color='red', dash='dash')\n        )\n    ],\n    layout=dict(\n        title='Soil Moisture in Summer Trend',\n        xaxis_title='Year',\n        yaxis_title='Soil Moisture (%)',\n        yaxis=dict(range=[y_min, y_max], tickfont=dict(size=14)),  # Set the y-axis range\n        title_font=dict(size=18, family='Arial, sans-serif'),\n        xaxis=dict(tickfont=dict(size=14)),\n        width=800,\n        height=600,\n        plot_bgcolor='#f7f7f7',\n        hoverlabel=dict(font_size=16),\n        showlegend=True,\n        legend=dict(\n            orientation='h',\n            yanchor='top',\n            y=-0.2,\n            xanchor='center',\n            x=0.5\n        )\n    )\n)\n\nfig1.show()\n\n\n                        \n                                            \nThe chart here displays the percentage of soil moisture during summer from 1980 to 2022. The red dashed trend line indicates an overall stable trend, with minor fluctuations over the years.\n\n\n\n\nTracking Summer Soil Dryness\n\n\nCode\nimport pandas as pd\nimport plotly.express as px\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport pandas as pd\nimport plotly.graph_objects as go\nimport seaborn as sns\nfrom sklearn.linear_model import LinearRegression\n\n# Load the cleaned datasets\nhistoric_data = pd.read_csv('./data/clean-data/historic_data_cleaned.csv')\nnearterm_data = pd.read_csv('./data/clean-data/nearterm_data_cleaned.csv')\n\n# Extracting the relevant column for DrySoilDays_Summer_whole analysis\nhistoric_soil_data_dry = historic_data[['year', 'DrySoilDays_Summer_whole']]\nnearterm_soil_data_dry = nearterm_data[['year', 'DrySoilDays_Summer_whole']]\ncombined_soil_data_dry = pd.concat([historic_soil_data_dry, nearterm_soil_data_dry])\ncombined_soil_data_dry_aggregated = combined_soil_data_dry.groupby('year').mean().reset_index()\n\n# Function to calculate trendline\ndef calculate_trendline(x, y):\n    model = LinearRegression()\n    x_reshaped = np.array(x).reshape(-1, 1)\n    model.fit(x_reshaped, y)\n    trend = model.predict(x_reshaped)\n    return trend\n\n# Calculate trendline for DrySoilDays_Summer_whole\ndry_soil_trend = calculate_trendline(combined_soil_data_dry_aggregated['year'], combined_soil_data_dry_aggregated['DrySoilDays_Summer_whole'])\n\n# Create the second area chart for DrySoilDays_Summer_whole with trendline\nfig2 = go.Figure(\n    data=[\n        go.Scatter(\n            x=combined_soil_data_dry_aggregated['year'],\n            y=combined_soil_data_dry_aggregated['DrySoilDays_Summer_whole'],\n            fill='tozeroy',\n            name='Dry Soil Days in Summer',\n            mode='none',\n            fillcolor='rgba(165,42,42,0.5)'\n        ),\n        go.Scatter(\n            x=combined_soil_data_dry_aggregated['year'],\n            y=dry_soil_trend,\n            mode='lines',\n            name='Trendline',\n            line=dict(color='blue', dash='dash')\n        )\n    ],\n    layout=dict(\n        title='Dry Soil Days in Summer Trend',\n        xaxis_title='Year',\n        yaxis_title='Dry Soil Days',\n        title_font=dict(size=18, family='Arial, sans-serif'),\n        xaxis=dict(tickfont=dict(size=14)),\n        yaxis=dict(tickfont=dict(size=14)),\n        width=800,\n        height=600,\n        plot_bgcolor='#f7f7f7',\n        hoverlabel=dict(font_size=16),\n        showlegend=True,\n        legend=dict(\n            orientation='h',\n            yanchor='top',\n            y=-0.2,\n            xanchor='center',\n            x=0.5\n        )\n    )\n)\n\n# Display the second plot\nfig2.show()\n\n\n                        \n                                            \nThis area chart outlines the number of dry soil days during summer over the years. The blue dashed trend line shows an increasing trend, indicating that the region is experiencing more dry soil days over time.\n\n\n\n\nNext up:\nSince rising temperatures and hotter days cause drier soils, does this mean evaporation is also affected speeds up in the Summers? This in turn could potentially affect the rainfall the area.",
    "crumbs": [
      "Chapter 2Ô∏è‚É£",
      "Soil"
    ]
  },
  {
    "objectID": "soil.html#subtitle",
    "href": "soil.html#subtitle",
    "title": "Soil",
    "section": "",
    "text": "More text\n\nüçÇ\n\n\n\n\n\nCode\nimport pandas as pd\nimport plotly.express as px\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport pandas as pd\nimport plotly.graph_objects as go\nimport seaborn as sns\nfrom sklearn.linear_model import LinearRegression\n\n# Load the cleaned datasets\nhistoric_data = pd.read_csv('./data/clean-data/historic_data_cleaned.csv')\nnearterm_data = pd.read_csv('./data/clean-data/nearterm_data_cleaned.csv')\n\n# Combine datasets for some visualizations\ncombined_data = pd.concat([historic_data, nearterm_data])\n\n# Group by year and calculate the average values for Tmax_Summer and VWC_Summer_whole\naverage_data = combined_data.groupby('year').agg({'Tmax_Summer': 'mean', 'VWC_Summer_whole': 'mean'}).reset_index()\n\n# Create the scatter plot to show the relationship between Tmax_Summer and VWC_Summer_whole\nfig = px.scatter(average_data, x='Tmax_Summer', y='VWC_Summer_whole',\n                 trendline='ols',  # Add a trendline\n                 title='Relationship Between Summer Maximum Temperature and Soil Moisture',\n                 labels={'Tmax_Summer': 'Maximum Summer Temperature (¬∞C)', 'VWC_Summer_whole': 'Average Soil Moisture (%)'})\n\n# Update layout for better aesthetics\nfig.update_layout(\n    title_font=dict(size=18, family='Arial, sans-serif'),\n    xaxis_title='Maximum Summer Temperature (¬∞C)',\n    yaxis_title='Average Soil Moisture (%)',\n    width=800,\n    height=600\n)\n\n\n                        \n                                            \nplace description here\n\n\n\n\n\n\n\nCode\nimport pandas as pd\nimport plotly.express as px\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport pandas as pd\nimport plotly.graph_objects as go\nimport seaborn as sns\nfrom sklearn.linear_model import LinearRegression\n\n# Load the cleaned datasets\nhistoric_data = pd.read_csv('./data/clean-data/historic_data_cleaned.csv')\nnearterm_data = pd.read_csv('./data/clean-data/nearterm_data_cleaned.csv')\n\n# Extracting the relevant column for VWC_Summer_whole analysis\nhistoric_soil_data_vwc = historic_data[['year', 'VWC_Summer_whole']]\nnearterm_soil_data_vwc = nearterm_data[['year', 'VWC_Summer_whole']]\ncombined_soil_data_vwc = pd.concat([historic_soil_data_vwc, nearterm_soil_data_vwc])\ncombined_soil_data_vwc_aggregated = combined_soil_data_vwc.groupby('year').mean().reset_index()\n\n# Extracting the relevant column for DrySoilDays_Summer_whole analysis\nhistoric_soil_data_dry = historic_data[['year', 'DrySoilDays_Summer_whole']]\nnearterm_soil_data_dry = nearterm_data[['year', 'DrySoilDays_Summer_whole']]\ncombined_soil_data_dry = pd.concat([historic_soil_data_dry, nearterm_soil_data_dry])\ncombined_soil_data_dry_aggregated = combined_soil_data_dry.groupby('year').mean().reset_index()\n\n# Function to calculate trendline\ndef calculate_trendline(x, y):\n    model = LinearRegression()\n    x_reshaped = np.array(x).reshape(-1, 1)\n    model.fit(x_reshaped, y)\n    trend = model.predict(x_reshaped)\n    return trend\n\n# Calculate trendline for VWC_Summer_whole\nvwc_trend = calculate_trendline(combined_soil_data_vwc_aggregated['year'], combined_soil_data_vwc_aggregated['VWC_Summer_whole'])\n\n# Determine the y-axis range to better show changes in moisture levels\ny_min = combined_soil_data_vwc_aggregated['VWC_Summer_whole'].min() - 0.005\ny_max = combined_soil_data_vwc_aggregated['VWC_Summer_whole'].max() + 0.005\n\n# Create the first area chart for VWC_Summer_whole with trendline\nfig1 = go.Figure(\n    data=[\n        go.Scatter(\n            x=combined_soil_data_vwc_aggregated['year'],\n            y=combined_soil_data_vwc_aggregated['VWC_Summer_whole'],\n            fill='tozeroy',\n            name='Soil Moisture in Summer',\n            mode='none',\n            fillcolor='#003c54'\n        ),\n        go.Scatter(\n            x=combined_soil_data_vwc_aggregated['year'],\n            y=vwc_trend,\n            mode='lines',\n            name='Trendline',\n            line=dict(color='red', dash='dash')\n        )\n    ],\n    layout=dict(\n        title='Soil Moisture in Summer Trend',\n        xaxis_title='Year',\n        yaxis_title='Soil Moisture (%)',\n        yaxis=dict(range=[y_min, y_max], tickfont=dict(size=14)),  # Set the y-axis range\n        title_font=dict(size=18, family='Arial, sans-serif'),\n        xaxis=dict(tickfont=dict(size=14)),\n        width=800,\n        height=600,\n        plot_bgcolor='#f7f7f7',\n        hoverlabel=dict(font_size=16),\n        showlegend=True,\n        legend=dict(\n            orientation='h',\n            yanchor='top',\n            y=-0.2,\n            xanchor='center',\n            x=0.5\n        )\n    )\n)\n\nfig1.show()\n\n\n                        \n                                            \nplace description here\n\n\n\n\n\n\n\nCode\nimport pandas as pd\nimport plotly.express as px\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport pandas as pd\nimport plotly.graph_objects as go\nimport seaborn as sns\nfrom sklearn.linear_model import LinearRegression\n\n# Load the cleaned datasets\nhistoric_data = pd.read_csv('./data/clean-data/historic_data_cleaned.csv')\nnearterm_data = pd.read_csv('./data/clean-data/nearterm_data_cleaned.csv')\n\n# Extracting the relevant column for DrySoilDays_Summer_whole analysis\nhistoric_soil_data_dry = historic_data[['year', 'DrySoilDays_Summer_whole']]\nnearterm_soil_data_dry = nearterm_data[['year', 'DrySoilDays_Summer_whole']]\ncombined_soil_data_dry = pd.concat([historic_soil_data_dry, nearterm_soil_data_dry])\ncombined_soil_data_dry_aggregated = combined_soil_data_dry.groupby('year').mean().reset_index()\n\n# Function to calculate trendline\ndef calculate_trendline(x, y):\n    model = LinearRegression()\n    x_reshaped = np.array(x).reshape(-1, 1)\n    model.fit(x_reshaped, y)\n    trend = model.predict(x_reshaped)\n    return trend\n\n# Calculate trendline for DrySoilDays_Summer_whole\ndry_soil_trend = calculate_trendline(combined_soil_data_dry_aggregated['year'], combined_soil_data_dry_aggregated['DrySoilDays_Summer_whole'])\n\n# Create the second area chart for DrySoilDays_Summer_whole with trendline\nfig2 = go.Figure(\n    data=[\n        go.Scatter(\n            x=combined_soil_data_dry_aggregated['year'],\n            y=combined_soil_data_dry_aggregated['DrySoilDays_Summer_whole'],\n            fill='tozeroy',\n            name='Dry Soil Days in Summer',\n            mode='none',\n            fillcolor='rgba(165,42,42,0.5)'\n        ),\n        go.Scatter(\n            x=combined_soil_data_dry_aggregated['year'],\n            y=dry_soil_trend,\n            mode='lines',\n            name='Trendline',\n            line=dict(color='blue', dash='dash')\n        )\n    ],\n    layout=dict(\n        title='Dry Soil Days in Summer Trend',\n        xaxis_title='Year',\n        yaxis_title='Dry Soil Days',\n        title_font=dict(size=18, family='Arial, sans-serif'),\n        xaxis=dict(tickfont=dict(size=14)),\n        yaxis=dict(tickfont=dict(size=14)),\n        width=800,\n        height=600,\n        plot_bgcolor='#f7f7f7',\n        hoverlabel=dict(font_size=16),\n        showlegend=True,\n        legend=dict(\n            orientation='h',\n            yanchor='top',\n            y=-0.2,\n            xanchor='center',\n            x=0.5\n        )\n    )\n)\n\n# Display the second plot\nfig2.show()\n\n\n                        \n                                            \nplace description here",
    "crumbs": [
      "Chapter 2Ô∏è‚É£",
      "Soil"
    ]
  },
  {
    "objectID": "evap.html",
    "href": "evap.html",
    "title": "Evaporation",
    "section": "",
    "text": "Let‚Äôs delve into the evaporation trends over the years. Previously, we observed low soil moisture levels and an increase in soil dryness which raises several questions about the effects of evaporation. Is high evaporation the potential cause of soil dryness, or are the two factors unrelated?\n\n\nCode\nlibrary(reticulate)\n\nuse_condaenv(\"base\", required = TRUE)\n\n\n\nShifting Evaporation Rates\n\n\nCode\nimport pandas as pd\nimport plotly.graph_objects as go\nfrom sklearn.linear_model import LinearRegression\nimport numpy as np\n\n# Load the cleaned datasets\nhistoric_data = pd.read_csv('./data/clean-data/historic_data_cleaned.csv')\nnearterm_data = pd.read_csv('./data/clean-data/nearterm_data_cleaned.csv')\n\n# Combine datasets for some visualizations\ncombined_data = pd.concat([historic_data, nearterm_data])\n\n# Extracting and merging the relevant columns for Evap_Summer analysis\ncombined_evap_data = combined_data[['year', 'Evap_Summer']]\n\n# Aggregating the data by year using the mean\ncombined_evap_aggregated = combined_evap_data.groupby('year').mean().reset_index()\n\n# Calculate trendline for Evap_Summer\ndef calculate_trendline(x, y):\n    model = LinearRegression()\n    x_reshaped = np.array(x).reshape(-1, 1)\n    model.fit(x_reshaped, y)\n    trend = model.predict(x_reshaped)\n    return trend\n\nevap_trend = calculate_trendline(combined_evap_aggregated['year'], combined_evap_aggregated['Evap_Summer'])\n\n# Create the Evaporation in Summer trend plot in one step\nfig1 = go.Figure(\n    data=[\n        go.Scatter(\n            x=combined_evap_aggregated['year'],\n            y=combined_evap_aggregated['Evap_Summer'],\n            mode='lines+markers',\n            line=dict(color='orange'),\n            hovertemplate='Year: %{x}&lt;br&gt;Evaporation: %{y}&lt;extra&gt;&lt;/extra&gt;',\n            name='Evaporation in Summer'\n        ),\n        go.Scatter(\n            x=combined_evap_aggregated['year'],\n            y=evap_trend,\n            mode='lines',\n            line=dict(color='blue', dash='dash'),\n            name='Trendline'\n        )\n    ],\n    layout=dict(\n        title='Evaporation in Summer Trend',\n        xaxis_title='Year',\n        yaxis_title='Evaporation in Summer',\n        title_font=dict(size=18, family='Arial, sans-serif'),\n        xaxis=dict(tickfont=dict(size=14)),\n        yaxis=dict(tickfont=dict(size=14)),\n        width=800,\n        height=600,\n        plot_bgcolor='#f7f7f7',\n        hoverlabel=dict(font_size=16),\n        showlegend=True,\n        legend=dict(\n            orientation='h',\n            yanchor='top',\n            y=-0.2,\n            xanchor='center',\n            x=0.5\n        )\n    )\n)\n\n# Display the first plot\nfig1.show()\n\n\n                        \n                                            \nThe line chart shows the trend in evaporation rates during summer. The orange line represents annual evaporation levels, and the trend line indicates a decreasing trend, suggesting lower rate in evaporation patterns over the years!\n\n\nThe combination of more dry soil days and decreasing evaporation suggests that the soil is not retaining moisture well, leading to drier conditions despite lower evaporation rates.\nThis potentially indicates that other factors such as reduced precipitation or higher temperatures are contributing to the drier soil conditions. Additionally, low moisture retention in higher temperatures could also be a reason for this phenomenon.\n\n\nExtreme Dry Stress Trends\n\n\nCode\nimport pandas as pd\nimport plotly.graph_objects as go\nfrom sklearn.linear_model import LinearRegression\nimport numpy as np\n\n# Load the cleaned datasets\nhistoric_data = pd.read_csv('./data/clean-data/historic_data_cleaned.csv')\nnearterm_data = pd.read_csv('./data/clean-data/nearterm_data_cleaned.csv')\n\n# Combine datasets for some visualizations\ncombined_data = pd.concat([historic_data, nearterm_data])\n\n# Aggregating the data by year using the mean\ncombined_evap_aggregated = combined_evap_data.groupby('year').mean().reset_index()\n\n# Calculate trendline for Evap_Summer\ndef calculate_trendline(x, y):\n    model = LinearRegression()\n    x_reshaped = np.array(x).reshape(-1, 1)\n    model.fit(x_reshaped, y)\n    trend = model.predict(x_reshaped)\n    return trend\n\n# Extracting and merging the relevant columns for ExtremeShortTermDryStress_Summer_whole analysis\ncombined_dry_stress_data = combined_data[['year', 'ExtremeShortTermDryStress_Summer_whole']]\n\n# Aggregating the data by year using the mean\ncombined_dry_stress_data_aggregated = combined_dry_stress_data.groupby('year').mean().reset_index()\n\n# Calculate trendline for ExtremeShortTermDryStress_Summer_whole\ndry_stress_trend = calculate_trendline(combined_dry_stress_data_aggregated['year'], combined_dry_stress_data_aggregated['ExtremeShortTermDryStress_Summer_whole'])\n\n# Create the Extreme Short Term Dry Stress in Summer trend plot in one step\nfig2 = go.Figure(\n    data=[\n        go.Scatter(\n            x=combined_dry_stress_data_aggregated['year'],\n            y=combined_dry_stress_data_aggregated['ExtremeShortTermDryStress_Summer_whole'],\n            mode='lines+markers',\n            line=dict(color='red'),\n            hovertemplate='Year: %{x}&lt;br&gt;Dry Stress: %{y}&lt;extra&gt;&lt;/extra&gt;',\n            name='Extreme Short Term Dry Stress'\n        ),\n        go.Scatter(\n            x=combined_dry_stress_data_aggregated['year'],\n            y=dry_stress_trend,\n            mode='lines',\n            line=dict(color='blue', dash='dash'),\n            name='Trendline'\n        )\n    ],\n    layout=dict(\n        title='Extreme Short Term Dry Stress in Summer Trend',\n        xaxis_title='Year',\n        yaxis_title='Extreme Short Term Dry Stress in Summer',\n        title_font=dict(size=18, family='Arial, sans-serif'),\n        xaxis=dict(tickfont=dict(size=14)),\n        yaxis=dict(tickfont=dict(size=14)),\n        width=800,\n        height=600,\n        plot_bgcolor='#f7f7f7',\n        hoverlabel=dict(font_size=16),\n        showlegend=True,\n        legend=dict(\n            orientation='h',\n            yanchor='top',\n            y=-0.2,\n            xanchor='center',\n            x=0.5\n        )\n    )\n)\n\n# Display the second plot\nfig2.show()\n\n\n                        \n                                            \nThis line chart shows the trend in extreme short-term dry stress during summer. The trend line shows an increasing trend, indicating worsening dry stress conditions.\n\n\n\n\nNext up:\nHow is precipitation affected by all of this? What is the potential impact of worsening dry stress conditions and lower rainfall?",
    "crumbs": [
      "Chapter 3Ô∏è‚É£",
      "Evaporation"
    ]
  },
  {
    "objectID": "evap.html#subtitle",
    "href": "evap.html#subtitle",
    "title": "Evaporation",
    "section": "",
    "text": "More text\n\nüí®\n\n\n\n\n\nCode\nimport pandas as pd\nimport plotly.graph_objects as go\nfrom sklearn.linear_model import LinearRegression\nimport numpy as np\n\n# Load the cleaned datasets\nhistoric_data = pd.read_csv('./data/clean-data/historic_data_cleaned.csv')\nnearterm_data = pd.read_csv('./data/clean-data/nearterm_data_cleaned.csv')\n\n# Combine datasets for some visualizations\ncombined_data = pd.concat([historic_data, nearterm_data])\n\n# Extracting and merging the relevant columns for Evap_Summer analysis\ncombined_evap_data = combined_data[['year', 'Evap_Summer']]\n\n# Aggregating the data by year using the mean\ncombined_evap_aggregated = combined_evap_data.groupby('year').mean().reset_index()\n\n# Calculate trendline for Evap_Summer\ndef calculate_trendline(x, y):\n    model = LinearRegression()\n    x_reshaped = np.array(x).reshape(-1, 1)\n    model.fit(x_reshaped, y)\n    trend = model.predict(x_reshaped)\n    return trend\n\nevap_trend = calculate_trendline(combined_evap_aggregated['year'], combined_evap_aggregated['Evap_Summer'])\n\n# Create the Evaporation in Summer trend plot in one step\nfig1 = go.Figure(\n    data=[\n        go.Scatter(\n            x=combined_evap_aggregated['year'],\n            y=combined_evap_aggregated['Evap_Summer'],\n            mode='lines+markers',\n            line=dict(color='orange'),\n            hovertemplate='Year: %{x}&lt;br&gt;Evaporation: %{y}&lt;extra&gt;&lt;/extra&gt;',\n            name='Evaporation in Summer'\n        ),\n        go.Scatter(\n            x=combined_evap_aggregated['year'],\n            y=evap_trend,\n            mode='lines',\n            line=dict(color='blue', dash='dash'),\n            name='Trendline'\n        )\n    ],\n    layout=dict(\n        title='Evaporation in Summer Trend',\n        xaxis_title='Year',\n        yaxis_title='Evaporation in Summer',\n        title_font=dict(size=18, family='Arial, sans-serif'),\n        xaxis=dict(tickfont=dict(size=14)),\n        yaxis=dict(tickfont=dict(size=14)),\n        width=800,\n        height=600,\n        plot_bgcolor='#f7f7f7',\n        hoverlabel=dict(font_size=16),\n        showlegend=True,\n        legend=dict(\n            orientation='h',\n            yanchor='top',\n            y=-0.2,\n            xanchor='center',\n            x=0.5\n        )\n    )\n)\n\n# Display the first plot\nfig1.show()\n\n\n                        \n                                            \nplace description here\n\n\nCode\n# Extracting and merging the relevant columns for ExtremeShortTermDryStress_Summer_whole analysis\ncombined_dry_stress_data = combined_data[['year', 'ExtremeShortTermDryStress_Summer_whole']]\n\n# Aggregating the data by year using the mean\ncombined_dry_stress_data_aggregated = combined_dry_stress_data.groupby('year').mean().reset_index()\n\n# Calculate trendline for ExtremeShortTermDryStress_Summer_whole\ndry_stress_trend = calculate_trendline(combined_dry_stress_data_aggregated['year'], combined_dry_stress_data_aggregated['ExtremeShortTermDryStress_Summer_whole'])\n\n# Create the Extreme Short Term Dry Stress in Summer trend plot in one step\nfig2 = go.Figure(\n    data=[\n        go.Scatter(\n            x=combined_dry_stress_data_aggregated['year'],\n            y=combined_dry_stress_data_aggregated['ExtremeShortTermDryStress_Summer_whole'],\n            mode='lines+markers',\n            line=dict(color='red'),\n            hovertemplate='Year: %{x}&lt;br&gt;Dry Stress: %{y}&lt;extra&gt;&lt;/extra&gt;',\n            name='Extreme Short Term Dry Stress'\n        ),\n        go.Scatter(\n            x=combined_dry_stress_data_aggregated['year'],\n            y=dry_stress_trend,\n            mode='lines',\n            line=dict(color='blue', dash='dash'),\n            name='Trendline'\n        )\n    ],\n    layout=dict(\n        title='Extreme Short Term Dry Stress in Summer Trend',\n        xaxis_title='Year',\n        yaxis_title='Extreme Short Term Dry Stress in Summer',\n        title_font=dict(size=18, family='Arial, sans-serif'),\n        xaxis=dict(tickfont=dict(size=14)),\n        yaxis=dict(tickfont=dict(size=14)),\n        width=800,\n        height=600,\n        plot_bgcolor='#f7f7f7',\n        hoverlabel=dict(font_size=16),\n        showlegend=True,\n        legend=dict(\n            orientation='h',\n            yanchor='top',\n            y=-0.2,\n            xanchor='center',\n            x=0.5\n        )\n    )\n)\n\n# Display the second plot\nfig2.show()\n\n\n                        \n                                            \nplace description here",
    "crumbs": [
      "Chapter 3Ô∏è‚É£",
      "Evaporation"
    ]
  },
  {
    "objectID": "ppt.html",
    "href": "ppt.html",
    "title": "Rain",
    "section": "",
    "text": "Since we discovered that evaporation rates have been decreasing over the past years, it would be interesting to see if rainfall has also decreased. In the water cycle, evaporation ultimately leads to rainfall, so it makes sense that less evaporation over the years could result in less rainfall.\n\n\nCode\nlibrary(reticulate)\n\nuse_condaenv(\"base\", required = TRUE)\n\n\n\nSummer Rain Stats\n\n\nCode\nimport pandas as pd\nimport plotly.express as px\nimport numpy as np\nimport plotly.express as px\nimport numpy as np\nimport seaborn as sns\nimport matplotlib.pyplot as plt\n\n# Load the cleaned datasets\nhistoric_data_1 = pd.read_csv('./data/clean-data/historic_data_cleaned.csv')\nnearterm_data_1 = pd.read_csv('./data/clean-data/nearterm_data_cleaned.csv')\n\n# Combine datasets for some visualizations\ncombined_data_1 = pd.concat([historic_data_1, nearterm_data_1])\n\n# Calculate the center of the map\ncenter_lat_1 = combined_data_1['lat'].mean()\ncenter_long_1 = combined_data_1['long'].mean()\n\n# Function to calculate an appropriate zoom level based on the spread of data points\ndef calculate_zoom_level_1(latitudes_1, longitudes_1):\n    max_lat_1, min_lat_1 = np.max(latitudes_1), np.min(latitudes_1)\n    max_long_1, min_long_1 = np.max(longitudes_1), np.min(longitudes_1)\n    lat_diff_1 = max_lat_1 - min_lat_1\n    long_diff_1 = max_long_1 - min_long_1\n    max_diff_1 = max(lat_diff_1, long_diff_1)\n    \n    if max_diff_1 &lt; 0.01:\n        return 15\n    elif max_diff_1 &lt; 0.1:\n        return 12\n    elif max_diff_1 &lt; 1:\n        return 10\n    elif max_diff_1 &lt; 10:\n        return 8\n    else:\n        return 6\n\n# Calculate zoom level (but we will manually adjust it for more zoom)\nzoom_level_1 = calculate_zoom_level_1(combined_data_1['lat'], combined_data_1['long'])\n\n# Manually adjust zoom level for a more zoomed-in view\nzoom_level_1 = zoom_level_1 * 0.95  # Increase the zoom factor\n\n# Set Mapbox access token\npx.set_mapbox_access_token(\"pk.eyJ1IjoiaXNmYXJiYXNldCIsImEiOiJjbHdiOWVtY2IwbGxsMmtraHZoYnB1YTMwIn0.10XSE1rNVsmXSnFmYYa0Cw\")\n\n# Create the Plotly scatter_mapbox map with enhanced aesthetics and detailed map layers\nmap_fig_1 = px.scatter_mapbox(combined_data_1, lon='long', lat='lat', color='PPT_Summer',\n                              hover_data={'PPT_Summer': ':.2f', 'lat': ':.2f', 'long': ':.2f', 'year': True}, size='PPT_Summer',\n                              labels={'PPT_Summer': 'summer precipitation', 'lat': 'latitude', 'long': 'longitude'},\n                              animation_frame='year', title='Geospatial Distribution of Summer Precipitation Over Time',\n                              color_continuous_scale=px.colors.sequential.Viridis_r, size_max=15, zoom=zoom_level_1,\n                              center={\"lat\": center_lat_1, \"lon\": center_long_1}\n                              )\n\n# Update the layout for better aesthetics and visibility of state lines\nmap_fig_1.update_layout(\n    mapbox_style=\"carto-positron\",  # Change the map style to show more details\n    mapbox=dict(\n        center=dict(lat=center_lat_1, lon=center_long_1),\n        zoom=zoom_level_1,  # Adjusted zoom level\n    ),\n    title_font=dict(size=18, family='Arial, sans-serif'),  \n    title_x=0.5,\n    coloraxis_colorbar=dict(\n        title=\"Summer Precipitation (inches)\",\n        title_side=\"right\",  # Align the title horizontally with the colorbar\n        title_font=dict(size=14)  # Adjust the font size as needed\n    ),\n    autosize=True,\n    width=750,  # Increase the width of the map\n    height=700   # Increase the height of the map\n)\n\n\n                        \n                                            \nThis animated map displays the geospatial distribution of summer precipitation in Southeastern Utah from 1980 to 2024. It visualizes changes in precipitation levels over time with the help of the color gradient, providing insights into evolving rainfall patterns in the region.\n\n\n\n\nPrecipitation Plot Twist\n\n\nCode\nimport pandas as pd\nimport plotly.express as px\nimport numpy as np\nimport plotly.express as px\nimport numpy as np\nimport seaborn as sns\nimport matplotlib.pyplot as plt\n\n\n# Load the cleaned datasets\nhistoric_data_1 = pd.read_csv('./data/clean-data/historic_data_cleaned.csv')\nnearterm_data_1 = pd.read_csv('./data/clean-data/nearterm_data_cleaned.csv')\n\n# Combine datasets for some visualizations\ncombined_data_1 = pd.concat([historic_data_1, nearterm_data_1])\n\n# Extracting the relevant column for analysis\nhistoric_ppt_data = historic_data_1[['year', 'PPT_Summer']]\nnearterm_ppt_data = nearterm_data_1[['year', 'PPT_Summer']]\n\n# Merging both datasets for a comprehensive analysis\ncombined_ppt_data = pd.concat([historic_ppt_data, nearterm_ppt_data])\n\n# Aggregating the data by year using the mean\ncombined_ppt_data_aggregated = combined_ppt_data.groupby('year').mean().reset_index()\n\n# Setting the style of the plot\nsns.set_theme(style=\"whitegrid\")\n\n# Plotting the PPT_Summer over the years with enhancements and a trendline\nplt.figure(figsize=(16, 9))\nsns.lineplot(data=combined_ppt_data_aggregated, x='year', y='PPT_Summer', marker='o', color='navy', linewidth=2.5, label='Summer Precipitation')\nsns.regplot(data=combined_ppt_data_aggregated, x='year', y='PPT_Summer', scatter=False, color='#4682B4', ci=None, line_kws={\"linewidth\":2.5, \"linestyle\":\"--\"}, label='Trendline')\n\n# Adding titles and labels with enhanced aesthetics\nplt.title('Summer Precipitation Trend\\n in Southeastern Utah', fontsize=32)\nplt.xlabel('Year', fontsize=25, weight='bold')\nplt.ylabel('Summer Precipitation (inches)', fontsize=25, weight='bold')\n\n# Setting the x-axis range from 1980 to 2024\n_ = plt.xlim(1980, 2024)\n\n# Adding a grid with customized appearance\n_ = plt.grid(True, linestyle='--', linewidth=0.7, alpha=0.7)\n\n# Enhancing the tick labels for better readability\n_ = plt.xticks(fontsize=20)\n_ = plt.yticks(fontsize=20)\n\n# Adding a light background color to the plot area\nplt.gca().set_facecolor('#f7f7f7')\n\n# Removing the top and right spines for a cleaner look\nsns.despine()\n\n# Adding legend\n_ = plt.legend(fontsize=20)\n\n# Display the plot\nplt.show()\n\n\n\n\n\nThis chart helps us examine the trend in summer precipitation in Southeastern Utah from 1980 to 2024. The trend line indicates a slightly decreasing trend, suggesting a potential decline in summer rainfall over time.\n\n\n\n\n\n\nNext up:\nLet‚Äôs summarize all our findings!",
    "crumbs": [
      "Chapter 4Ô∏è‚É£",
      "Rain"
    ]
  },
  {
    "objectID": "ppt.html#subtitle",
    "href": "ppt.html#subtitle",
    "title": "Rain",
    "section": "",
    "text": "More text\n\nüåßÔ∏è\n\n\n\n\n\nCode\nimport pandas as pd\nimport plotly.express as px\nimport numpy as np\nimport plotly.express as px\nimport numpy as np\nimport seaborn as sns\nimport matplotlib.pyplot as plt\n\n# Load the cleaned datasets\nhistoric_data_1 = pd.read_csv('./data/clean-data/historic_data_cleaned.csv')\nnearterm_data_1 = pd.read_csv('./data/clean-data/nearterm_data_cleaned.csv')\n\n# Combine datasets for some visualizations\ncombined_data_1 = pd.concat([historic_data_1, nearterm_data_1])\n\n# Calculate the center of the map\ncenter_lat_1 = combined_data_1['lat'].mean()\ncenter_long_1 = combined_data_1['long'].mean()\n\n# Function to calculate an appropriate zoom level based on the spread of data points\ndef calculate_zoom_level_1(latitudes_1, longitudes_1):\n    max_lat_1, min_lat_1 = np.max(latitudes_1), np.min(latitudes_1)\n    max_long_1, min_long_1 = np.max(longitudes_1), np.min(longitudes_1)\n    lat_diff_1 = max_lat_1 - min_lat_1\n    long_diff_1 = max_long_1 - min_long_1\n    max_diff_1 = max(lat_diff_1, long_diff_1)\n    \n    if max_diff_1 &lt; 0.01:\n        return 15\n    elif max_diff_1 &lt; 0.1:\n        return 12\n    elif max_diff_1 &lt; 1:\n        return 10\n    elif max_diff_1 &lt; 10:\n        return 8\n    else:\n        return 6\n\n# Calculate zoom level (but we will manually adjust it for more zoom)\nzoom_level_1 = calculate_zoom_level_1(combined_data_1['lat'], combined_data_1['long'])\n\n# Manually adjust zoom level for a more zoomed-in view\nzoom_level_1 = zoom_level_1 * 0.95  # Increase the zoom factor\n\n# Set Mapbox access token\npx.set_mapbox_access_token(\"pk.eyJ1IjoiaXNmYXJiYXNldCIsImEiOiJjbHdiOWVtY2IwbGxsMmtraHZoYnB1YTMwIn0.10XSE1rNVsmXSnFmYYa0Cw\")\n\n# Create the Plotly scatter_mapbox map with enhanced aesthetics and detailed map layers\nmap_fig_1 = px.scatter_mapbox(combined_data_1, lon='long', lat='lat', color='PPT_Summer',\n                              hover_data={'PPT_Summer': ':.2f', 'lat': ':.2f', 'long': ':.2f', 'year': True}, size='PPT_Summer',\n                              labels={'PPT_Summer': 'summer precipitation', 'lat': 'latitude', 'long': 'longitude'},\n                              animation_frame='year', title='Geospatial Distribution of Summer Precipitation Over Time',\n                              color_continuous_scale=px.colors.sequential.Viridis_r, size_max=15, zoom=zoom_level_1,\n                              center={\"lat\": center_lat_1, \"lon\": center_long_1}\n                              )\n\n# Update the layout for better aesthetics and visibility of state lines\nmap_fig_1.update_layout(\n    mapbox_style=\"carto-positron\",  # Change the map style to show more details\n    mapbox=dict(\n        center=dict(lat=center_lat_1, lon=center_long_1),\n        zoom=zoom_level_1,  # Adjusted zoom level\n    ),\n    title_font=dict(size=18, family='Arial, sans-serif'),  \n    title_x=0.5,\n    coloraxis_colorbar=dict(\n        title=\"Summer Precipitation (inches)\",\n        title_side=\"right\",  # Align the title horizontally with the colorbar\n        title_font=dict(size=14)  # Adjust the font size as needed\n    ),\n    autosize=True,\n    width=750,  # Increase the width of the map\n    height=700   # Increase the height of the map\n)\n\n\n                        \n                                            \nplace description here\n\n\nCode\n# Load the cleaned datasets\nhistoric_data_1 = pd.read_csv('./data/clean-data/historic_data_cleaned.csv')\nnearterm_data_1 = pd.read_csv('./data/clean-data/nearterm_data_cleaned.csv')\n\n# Combine datasets for some visualizations\ncombined_data_1 = pd.concat([historic_data_1, nearterm_data_1])\n\n# Extracting the relevant column for analysis\nhistoric_ppt_data = historic_data_1[['year', 'PPT_Summer']]\nnearterm_ppt_data = nearterm_data_1[['year', 'PPT_Summer']]\n\n# Merging both datasets for a comprehensive analysis\ncombined_ppt_data = pd.concat([historic_ppt_data, nearterm_ppt_data])\n\n# Aggregating the data by year using the mean\ncombined_ppt_data_aggregated = combined_ppt_data.groupby('year').mean().reset_index()\n\n# Setting the style of the plot\nsns.set_theme(style=\"whitegrid\")\n\n# Plotting the PPT_Summer over the years with enhancements and a trendline\nplt.figure(figsize=(16, 9))\nsns.lineplot(data=combined_ppt_data_aggregated, x='year', y='PPT_Summer', marker='o', color='navy', linewidth=2.5, label='Summer Precipitation')\nsns.regplot(data=combined_ppt_data_aggregated, x='year', y='PPT_Summer', scatter=False, color='#4682B4', ci=None, line_kws={\"linewidth\":2.5, \"linestyle\":\"--\"}, label='Trendline')\n\n# Adding titles and labels with enhanced aesthetics\nplt.title('Summer Precipitation Trend\\n in Southeastern Utah', fontsize=32)\nplt.xlabel('Year', fontsize=25, weight='bold')\nplt.ylabel('Summer Precipitation (inches)', fontsize=25, weight='bold')\n\n# Setting the x-axis range from 1980 to 2024\n_ = plt.xlim(1980, 2024)\n\n# Adding a grid with customized appearance\n_ = plt.grid(True, linestyle='--', linewidth=0.7, alpha=0.7)\n\n# Enhancing the tick labels for better readability\n_ = plt.xticks(fontsize=20)\n_ = plt.yticks(fontsize=20)\n\n# Adding a light background color to the plot area\nplt.gca().set_facecolor('#f7f7f7')\n\n# Removing the top and right spines for a cleaner look\nsns.despine()\n\n# Adding legend\n_ = plt.legend(fontsize=20)\n\n# Display the plot\nplt.show()\n\n\n\n\n\nplace description here",
    "crumbs": [
      "Chapter 4Ô∏è‚É£",
      "Rain"
    ]
  },
  {
    "objectID": "max-heat.html",
    "href": "max-heat.html",
    "title": "Maximum Temperature",
    "section": "",
    "text": "Text here\n\n\nCode\nlibrary(reticulate)\n\nuse_condaenv(\"base\", required = TRUE)\n\n\n\n\nMore text\n\nü•µ\n\n\n\n\n\nCode\nimport pandas as pd\nimport plotly.express as px\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport seaborn as sns\n\n# Load the cleaned datasets\nhistoric_data_1 = pd.read_csv('./data/clean-data/historic_data_cleaned.csv')\nnearterm_data_1 = pd.read_csv('./data/clean-data/nearterm_data_cleaned.csv')\n\n# Combine datasets for some visualizations\ncombined_data_1 = pd.concat([historic_data_1, nearterm_data_1])\n\n# Calculate the center of the map\ncenter_lat_1 = combined_data_1['lat'].mean()\ncenter_long_1 = combined_data_1['long'].mean()\n\n# Function to calculate an appropriate zoom level based on the spread of data points\ndef calculate_zoom_level_1(latitudes_1, longitudes_1):\n    max_lat_1, min_lat_1 = np.max(latitudes_1), np.min(latitudes_1)\n    max_long_1, min_long_1 = np.max(longitudes_1), np.min(longitudes_1)\n    lat_diff_1 = max_lat_1 - min_lat_1\n    long_diff_1 = max_long_1 - min_long_1\n    max_diff_1 = max(lat_diff_1, long_diff_1)\n    \n    if max_diff_1 &lt; 0.01:\n        return 15\n    elif max_diff_1 &lt; 0.1:\n        return 12\n    elif max_diff_1 &lt; 1:\n        return 10\n    elif max_diff_1 &lt; 10:\n        return 8\n    else:\n        return 6\n\n# Calculate zoom level (but we will manually adjust it for more zoom)\nzoom_level_1 = calculate_zoom_level_1(combined_data_1['lat'], combined_data_1['long'])\n\n# Manually adjust zoom level for a more zoomed-in view\nzoom_level_1 = zoom_level_1 * 0.95  # Increase the zoom factor\n\n# Set Mapbox access token\npx.set_mapbox_access_token(\"pk.eyJ1IjoiaXNmYXJiYXNldCIsImEiOiJjbHdiOWVtY2IwbGxsMmtraHZoYnB1YTMwIn0.10XSE1rNVsmXSnFmYYa0Cw\")\n\n# Create the Plotly scatter_mapbox map with enhanced aesthetics and detailed map layers\nmap_fig_1 = px.scatter_mapbox(combined_data_1, lon='long', lat='lat', color='Tmax_Summer',\n                            hover_data={'Tmax_Summer': ':.2f', 'lat': ':.2f', 'long': ':.2f', 'year': True}, size='Tmax_Summer',\n                            labels={'Tmax_Summer': 'max temp', 'lat': 'latitude', 'long': 'longitude'},\n                            animation_frame='year', title='Geospatial Distribution of Maximum Temperature Over Time',\n                            color_continuous_scale=px.colors.sequential.Sunsetdark, size_max=15, zoom=zoom_level_1,\n                            center={\"lat\": center_lat_1, \"lon\": center_long_1}\n                            )\n\n# Update the layout for better aesthetics and visibility of state lines\nmap_fig_1.update_layout(\n    mapbox_style=\"carto-positron\",  # Change the map style to show more details\n    mapbox=dict(\n        center=dict(lat=center_lat_1, lon=center_long_1),\n        zoom=zoom_level_1,  # Adjusted zoom level\n    ),\n    title_font=dict(size=18, family='Arial, sans-serif'),  \n    title_x=0.5,\n    coloraxis_colorbar=dict(\n        title=\"Maximum Temperature(¬∞C)\",\n        title_side=\"right\",  # Align the title horizontally with the colorbar\n        title_font=dict(size=14)  # Adjust the font size as needed\n    ),\n    autosize=True,\n    width=750,  # Increase the width of the map\n    height=700   # Increase the height of the map\n)\n\n\n                        \n                                            \nplace description here\n\n\nCode\n# Extracting the relevant column for analysis\nhistoric_tmax_data = historic_data_1[['year', 'Tmax_Summer']]\nnearterm_tmax_data = nearterm_data_1[['year', 'Tmax_Summer']]\n\n# Merging both datasets for a comprehensive analysis\ncombined_tmax_data = pd.concat([historic_tmax_data, nearterm_tmax_data])\n\n# Aggregating the data by year using the mean\ncombined_tmax_data_aggregated = combined_tmax_data.groupby('year').mean().reset_index()\n\n# Setting the style of the plot\nsns.set_theme(style=\"whitegrid\")\n\n# Plotting the Tmax_Summer over the years with enhancements\nplt.figure(figsize=(16, 9))\nsns.lineplot(data=combined_tmax_data_aggregated, x='year', y='Tmax_Summer', marker='o', color='#AA4A44', linewidth=2.5)\n\n# Adding titles and labels with enhanced aesthetics\nplt.title('Maximum Temperature Trend\\n in Southeastern Utah', fontsize=32)\nplt.xlabel('Year', fontsize=25, weight='bold')\nplt.ylabel('Maximum Temperature (¬∞C)', fontsize=25, weight='bold')\n\n# Adding a grid with customized appearance\nplt.grid(True, linestyle='--', linewidth=0.7, alpha=0.7)\n\n# Enhancing the tick labels for better readability\n_ = plt.xticks(fontsize=20)\n_ = plt.yticks(fontsize=20)\n\n# Adding a light background color to the plot area\nplt.gca().set_facecolor('#f7f7f7')\n\n# Removing the top and right spines for a cleaner look\nsns.despine()\n\n# Display the plot\nplt.show()\n\n\n\n\n\nplace description here",
    "crumbs": [
      "1Ô∏è‚É£",
      "Maximum Temperature"
    ]
  },
  {
    "objectID": "max-heat.html#subtitle",
    "href": "max-heat.html#subtitle",
    "title": "Maximum Temperature",
    "section": "",
    "text": "More text\n\nü•µ\n\n\n\n\n\nCode\nimport pandas as pd\nimport plotly.express as px\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport seaborn as sns\n\n# Load the cleaned datasets\nhistoric_data_1 = pd.read_csv('./data/clean-data/historic_data_cleaned.csv')\nnearterm_data_1 = pd.read_csv('./data/clean-data/nearterm_data_cleaned.csv')\n\n# Combine datasets for some visualizations\ncombined_data_1 = pd.concat([historic_data_1, nearterm_data_1])\n\n# Calculate the center of the map\ncenter_lat_1 = combined_data_1['lat'].mean()\ncenter_long_1 = combined_data_1['long'].mean()\n\n# Function to calculate an appropriate zoom level based on the spread of data points\ndef calculate_zoom_level_1(latitudes_1, longitudes_1):\n    max_lat_1, min_lat_1 = np.max(latitudes_1), np.min(latitudes_1)\n    max_long_1, min_long_1 = np.max(longitudes_1), np.min(longitudes_1)\n    lat_diff_1 = max_lat_1 - min_lat_1\n    long_diff_1 = max_long_1 - min_long_1\n    max_diff_1 = max(lat_diff_1, long_diff_1)\n    \n    if max_diff_1 &lt; 0.01:\n        return 15\n    elif max_diff_1 &lt; 0.1:\n        return 12\n    elif max_diff_1 &lt; 1:\n        return 10\n    elif max_diff_1 &lt; 10:\n        return 8\n    else:\n        return 6\n\n# Calculate zoom level (but we will manually adjust it for more zoom)\nzoom_level_1 = calculate_zoom_level_1(combined_data_1['lat'], combined_data_1['long'])\n\n# Manually adjust zoom level for a more zoomed-in view\nzoom_level_1 = zoom_level_1 * 0.95  # Increase the zoom factor\n\n# Set Mapbox access token\npx.set_mapbox_access_token(\"pk.eyJ1IjoiaXNmYXJiYXNldCIsImEiOiJjbHdiOWVtY2IwbGxsMmtraHZoYnB1YTMwIn0.10XSE1rNVsmXSnFmYYa0Cw\")\n\n# Create the Plotly scatter_mapbox map with enhanced aesthetics and detailed map layers\nmap_fig_1 = px.scatter_mapbox(combined_data_1, lon='long', lat='lat', color='Tmax_Summer',\n                            hover_data={'Tmax_Summer': ':.2f', 'lat': ':.2f', 'long': ':.2f', 'year': True}, size='Tmax_Summer',\n                            labels={'Tmax_Summer': 'max temp', 'lat': 'latitude', 'long': 'longitude'},\n                            animation_frame='year', title='Geospatial Distribution of Maximum Temperature Over Time',\n                            color_continuous_scale=px.colors.sequential.Sunsetdark, size_max=15, zoom=zoom_level_1,\n                            center={\"lat\": center_lat_1, \"lon\": center_long_1}\n                            )\n\n# Update the layout for better aesthetics and visibility of state lines\nmap_fig_1.update_layout(\n    mapbox_style=\"carto-positron\",  # Change the map style to show more details\n    mapbox=dict(\n        center=dict(lat=center_lat_1, lon=center_long_1),\n        zoom=zoom_level_1,  # Adjusted zoom level\n    ),\n    title_font=dict(size=18, family='Arial, sans-serif'),  \n    title_x=0.5,\n    coloraxis_colorbar=dict(\n        title=\"Maximum Temperature(¬∞C)\",\n        title_side=\"right\",  # Align the title horizontally with the colorbar\n        title_font=dict(size=14)  # Adjust the font size as needed\n    ),\n    autosize=True,\n    width=750,  # Increase the width of the map\n    height=700   # Increase the height of the map\n)\n\n\n                        \n                                            \nplace description here\n\n\nCode\n# Extracting the relevant column for analysis\nhistoric_tmax_data = historic_data_1[['year', 'Tmax_Summer']]\nnearterm_tmax_data = nearterm_data_1[['year', 'Tmax_Summer']]\n\n# Merging both datasets for a comprehensive analysis\ncombined_tmax_data = pd.concat([historic_tmax_data, nearterm_tmax_data])\n\n# Aggregating the data by year using the mean\ncombined_tmax_data_aggregated = combined_tmax_data.groupby('year').mean().reset_index()\n\n# Setting the style of the plot\nsns.set_theme(style=\"whitegrid\")\n\n# Plotting the Tmax_Summer over the years with enhancements\nplt.figure(figsize=(16, 9))\nsns.lineplot(data=combined_tmax_data_aggregated, x='year', y='Tmax_Summer', marker='o', color='#AA4A44', linewidth=2.5)\n\n# Adding titles and labels with enhanced aesthetics\nplt.title('Maximum Temperature Trend\\n in Southeastern Utah', fontsize=32)\nplt.xlabel('Year', fontsize=25, weight='bold')\nplt.ylabel('Maximum Temperature (¬∞C)', fontsize=25, weight='bold')\n\n# Adding a grid with customized appearance\nplt.grid(True, linestyle='--', linewidth=0.7, alpha=0.7)\n\n# Enhancing the tick labels for better readability\n_ = plt.xticks(fontsize=20)\n_ = plt.yticks(fontsize=20)\n\n# Adding a light background color to the plot area\nplt.gca().set_facecolor('#f7f7f7')\n\n# Removing the top and right spines for a cleaner look\nsns.despine()\n\n# Display the plot\nplt.show()\n\n\n\n\n\nplace description here",
    "crumbs": [
      "1Ô∏è‚É£",
      "Maximum Temperature"
    ]
  },
  {
    "objectID": "temp.html",
    "href": "temp.html",
    "title": "Temperature",
    "section": "",
    "text": "In this section, we will take a closer look at summer temperature levels. Previously, we observed a rising trend in maximum temperatures over the past few years. This section continues that discussion by comparing summer heat levels from the past to the present!\n\n\nCode\nlibrary(reticulate)\n\nuse_condaenv(\"base\", required = TRUE)\n\n\n\nThe Summer Heat Story\n\n\nCode\nimport pandas as pd\nimport plotly.graph_objects as go\nfrom sklearn.linear_model import LinearRegression\nimport numpy as np\n\n# Load the cleaned datasets\nhistoric_data = pd.read_csv('./data/clean-data/historic_data_cleaned.csv')\nnearterm_data = pd.read_csv('./data/clean-data/nearterm_data_cleaned.csv')\n\n# Combine datasets for some visualizations\ncombined_data = pd.concat([historic_data, nearterm_data])\n\n# Extracting and merging the relevant columns for T_Summer analysis\ncombined_t_summer_data = combined_data[['year', 'T_Summer']]\n\n# Aggregating the data by year using the mean\ncombined_t_summer_aggregated = combined_t_summer_data.groupby('year').mean().reset_index()\n\n# Calculate trendline for combined data\ndef calculate_trendline(x, y):\n    model = LinearRegression()\n    x_reshaped = np.array(x).reshape(-1, 1)\n    model.fit(x_reshaped, y)\n    trend = model.predict(x_reshaped)\n    return trend\n\nt_summer_trend = calculate_trendline(combined_t_summer_aggregated['year'], combined_t_summer_aggregated['T_Summer'])\n\n# Create a custom colorscale with cerulean for lower values and deep navy blue for higher values\ncustom_colorscale = [\n    [0.0, 'rgb(255,192,12)'],  # yellow ochre\n    [1.0,  'rgb(150,0,0)']  # deep navy red\n]\n\n# Create bubble chart with trendline and update layout\nfig = go.Figure(\n    data=[\n        go.Scatter(\n            x=combined_t_summer_aggregated['year'],\n            y=combined_t_summer_aggregated['T_Summer'],\n            mode='markers',\n            marker=dict(\n                size=combined_t_summer_aggregated['T_Summer'],\n                color=combined_t_summer_aggregated['T_Summer'],\n                colorscale=custom_colorscale,\n                sizemode='area',\n                sizeref=2.*max(combined_t_summer_aggregated['T_Summer'])/(40.**2),  # Adjusted sizeref to make bubbles smaller\n                sizemin=3  # Adjusted sizemin to make the smallest bubbles smaller\n            ),\n            hovertemplate='Year: %{x}&lt;br&gt;Temperature: %{y:.2f} ¬∞C&lt;extra&gt;&lt;/extra&gt;',\n            name='Summer Temperature'\n        ),\n        go.Scatter(\n            x=combined_t_summer_aggregated['year'],\n            y=t_summer_trend,\n            mode='lines',\n            line=dict(color='red', dash='dash'),\n            hovertemplate='Year: %{x}&lt;br&gt;Trend: %{y:.2f} ¬∞C&lt;extra&gt;&lt;/extra&gt;',\n            name='Trendline'\n        )\n    ],\n    layout=dict(\n        title='Summer Temperature Trend',\n        xaxis_title='Year',\n        yaxis_title='Summer Temperature (¬∞C)',\n        title_font=dict(size=18, family='Arial, sans-serif'),\n        xaxis=dict(tickfont=dict(size=14)),\n        yaxis=dict(tickfont=dict(size=14)),\n        width=800,\n        height=600,\n        plot_bgcolor='#f7f7f7',\n        hoverlabel=dict(font_size=16),\n        showlegend=False,\n        legend=dict(\n            orientation='h',\n            yanchor='top',\n            y=-0.2,\n            xanchor='center',\n            x=0.5\n        )\n    )\n)\n\n# Display the plot\nfig.show()\n\n\n                        \n                                            \nThis scatter plot and trend line depicts the changes in average summer temperatures over the years. The color gradient from yellow to red indicates temperature levels, with the darker red hues representing higher temperatures. The increasing trend line suggests a gradual rise in summer temperatures.\n\n\n\n\nNext up:\nSoutheastern Utah is home to a diverse ecosystem that relies on soil conditions. Are rising heat levels affecting this resource?",
    "crumbs": [
      "Chapter 1Ô∏è‚É£",
      "Temperature"
    ]
  },
  {
    "objectID": "temp.html#subtitle",
    "href": "temp.html#subtitle",
    "title": "Temperature",
    "section": "",
    "text": "More text\n\nü•µ\n\n\n\n\n\nCode\nimport pandas as pd\nimport plotly.graph_objects as go\nfrom sklearn.linear_model import LinearRegression\nimport numpy as np\n\n# Load the cleaned datasets\nhistoric_data = pd.read_csv('./data/clean-data/historic_data_cleaned.csv')\nnearterm_data = pd.read_csv('./data/clean-data/nearterm_data_cleaned.csv')\n\n# Combine datasets for some visualizations\ncombined_data = pd.concat([historic_data, nearterm_data])\n\n# Extracting and merging the relevant columns for T_Summer analysis\ncombined_t_summer_data = combined_data[['year', 'T_Summer']]\n\n# Aggregating the data by year using the mean\ncombined_t_summer_aggregated = combined_t_summer_data.groupby('year').mean().reset_index()\n\n# Calculate trendline for combined data\ndef calculate_trendline(x, y):\n    model = LinearRegression()\n    x_reshaped = np.array(x).reshape(-1, 1)\n    model.fit(x_reshaped, y)\n    trend = model.predict(x_reshaped)\n    return trend\n\nt_summer_trend = calculate_trendline(combined_t_summer_aggregated['year'], combined_t_summer_aggregated['T_Summer'])\n\n# Create a custom colorscale with cerulean for lower values and deep navy blue for higher values\ncustom_colorscale = [\n    [0.0, 'rgb(255,192,12)'],  # yellow ochre\n    [1.0,  'rgb(150,0,0)']  # deep navy red\n]\n\n# Create bubble chart with trendline and update layout\nfig = go.Figure(\n    data=[\n        go.Scatter(\n            x=combined_t_summer_aggregated['year'],\n            y=combined_t_summer_aggregated['T_Summer'],\n            mode='markers',\n            marker=dict(\n                size=combined_t_summer_aggregated['T_Summer'],\n                color=combined_t_summer_aggregated['T_Summer'],\n                colorscale=custom_colorscale,\n                sizemode='area',\n                sizeref=2.*max(combined_t_summer_aggregated['T_Summer'])/(40.**2),  # Adjusted sizeref to make bubbles smaller\n                sizemin=3  # Adjusted sizemin to make the smallest bubbles smaller\n            ),\n            hovertemplate='Year: %{x}&lt;br&gt;Temperature: %{y:.2f} ¬∞C&lt;extra&gt;&lt;/extra&gt;',\n            name='Summer Temperature'\n        ),\n        go.Scatter(\n            x=combined_t_summer_aggregated['year'],\n            y=t_summer_trend,\n            mode='lines',\n            line=dict(color='red', dash='dash'),\n            hovertemplate='Year: %{x}&lt;br&gt;Trend: %{y:.2f} ¬∞C&lt;extra&gt;&lt;/extra&gt;',\n            name='Trendline'\n        )\n    ],\n    layout=dict(\n        title='Summer Temperature Trend',\n        xaxis_title='Year',\n        yaxis_title='Summer Temperature (¬∞C)',\n        title_font=dict(size=18, family='Arial, sans-serif'),\n        xaxis=dict(tickfont=dict(size=14)),\n        yaxis=dict(tickfont=dict(size=14)),\n        width=800,\n        height=600,\n        plot_bgcolor='#f7f7f7',\n        hoverlabel=dict(font_size=16),\n        showlegend=False,\n        legend=dict(\n            orientation='h',\n            yanchor='top',\n            y=-0.2,\n            xanchor='center',\n            x=0.5\n        )\n    )\n)\n\n# Display the plot\nfig.show()\n\n\n                        \n                                            \nplace description here",
    "crumbs": [
      "Chapter 1Ô∏è‚É£",
      "Temperature"
    ]
  },
  {
    "objectID": "conclusion.html",
    "href": "conclusion.html",
    "title": "Conclusion",
    "section": "",
    "text": "It‚Äôs a wrap",
    "crumbs": [
      "Chapter 5Ô∏è‚É£",
      "Conclusion"
    ]
  }
]