[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Introduction",
    "section": "",
    "text": "Code\nlibrary(reticulate)\n\nuse_condaenv(\"base\", required = TRUE)\n\n\n\nü•µ\n\n\nVisualization 1\n\n\nCode\nimport pandas as pd\nimport plotly.express as px\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport seaborn as sns\n\n# Load the cleaned datasets\nhistoric_data_1 = pd.read_csv('./data/clean-data/historic_data_cleaned.csv')\nnearterm_data_1 = pd.read_csv('./data/clean-data/nearterm_data_cleaned.csv')\n\n# Combine datasets for some visualizations\ncombined_data_1 = pd.concat([historic_data_1, nearterm_data_1])\n\n# Calculate the center of the map\ncenter_lat_1 = combined_data_1['lat'].mean()\ncenter_long_1 = combined_data_1['long'].mean()\n\n# Function to calculate an appropriate zoom level based on the spread of data points\ndef calculate_zoom_level_1(latitudes_1, longitudes_1):\n    max_lat_1, min_lat_1 = np.max(latitudes_1), np.min(latitudes_1)\n    max_long_1, min_long_1 = np.max(longitudes_1), np.min(longitudes_1)\n    lat_diff_1 = max_lat_1 - min_lat_1\n    long_diff_1 = max_long_1 - min_long_1\n    max_diff_1 = max(lat_diff_1, long_diff_1)\n    \n    if max_diff_1 &lt; 0.01:\n        return 15\n    elif max_diff_1 &lt; 0.1:\n        return 12\n    elif max_diff_1 &lt; 1:\n        return 10\n    elif max_diff_1 &lt; 10:\n        return 8\n    else:\n        return 6\n\n# Calculate zoom level (but we will manually adjust it for more zoom)\nzoom_level_1 = calculate_zoom_level_1(combined_data_1['lat'], combined_data_1['long'])\n\n# Manually adjust zoom level for a more zoomed-in view\nzoom_level_1 = zoom_level_1 * 0.95  # Increase the zoom factor\n\n# Set Mapbox access token\npx.set_mapbox_access_token(\"pk.eyJ1IjoiaXNmYXJiYXNldCIsImEiOiJjbHdiOWVtY2IwbGxsMmtraHZoYnB1YTMwIn0.10XSE1rNVsmXSnFmYYa0Cw\")\n\n# Create the Plotly scatter_mapbox map with enhanced aesthetics and detailed map layers\nmap_fig_1 = px.scatter_mapbox(combined_data_1, lon='long', lat='lat', color='Tmax_Summer',\n                            hover_data={'Tmax_Summer': ':.2f', 'lat': ':.2f', 'long': ':.2f', 'year': True}, size='Tmax_Summer',\n                            labels={'Tmax_Summer': 'max temp', 'lat': 'latitude', 'long': 'longitude'},\n                            animation_frame='year', title='Geospatial Distribution of Maximum Temperature Over Time',\n                            color_continuous_scale=px.colors.sequential.Sunsetdark, size_max=15, zoom=zoom_level_1,\n                            center={\"lat\": center_lat_1, \"lon\": center_long_1}\n                            )\n\n# Update the layout for better aesthetics and visibility of state lines\nmap_fig_1.update_layout(\n    mapbox_style=\"carto-positron\",  # Change the map style to show more details\n    mapbox=dict(\n        center=dict(lat=center_lat_1, lon=center_long_1),\n        zoom=zoom_level_1,  # Adjusted zoom level\n    ),\n    title_font=dict(size=18, family='Arial, sans-serif'),  \n    title_x=0.5,\n    coloraxis_colorbar=dict(\n        title=\"Maximum Temperature(¬∞C)\",\n        title_side=\"right\",  # Align the title horizontally with the colorbar\n        title_font=dict(size=14)  # Adjust the font size as needed\n    ),\n    autosize=True,\n    width=750,  # Increase the width of the map\n    height=700   # Increase the height of the map\n)\n\n\n                        \n                                            \nplace description here\n\n\nCode\n# Extracting the relevant column for analysis\nhistoric_tmax_data = historic_data_1[['year', 'Tmax_Summer']]\nnearterm_tmax_data = nearterm_data_1[['year', 'Tmax_Summer']]\n\n# Merging both datasets for a comprehensive analysis\ncombined_tmax_data = pd.concat([historic_tmax_data, nearterm_tmax_data])\n\n# Aggregating the data by year using the mean\ncombined_tmax_data_aggregated = combined_tmax_data.groupby('year').mean().reset_index()\n\n# Setting the style of the plot\nsns.set_theme(style=\"whitegrid\")\n\n# Plotting the Tmax_Summer over the years with enhancements and a trendline\nplt.figure(figsize=(16, 9))\nsns.lineplot(data=combined_tmax_data_aggregated, x='year', y='Tmax_Summer', marker='o', color='maroon', linewidth=2.5, label='Maximum Summer Temperature')\nsns.regplot(data=combined_tmax_data_aggregated, x='year', y='Tmax_Summer', scatter=False, color='red', ci=None, line_kws={\"linewidth\":2.5, \"linestyle\":\"--\"}, label='Trendline')\n\n# Adding titles and labels with enhanced aesthetics\nplt.title('Maximum Temperature Trend\\n in Southeastern Utah', fontsize=32)\nplt.xlabel('Year', fontsize=25, weight='bold')\nplt.ylabel('Maximum Temperature (¬∞C)', fontsize=25, weight='bold')\n\n# Setting the x-axis range from 1980 to 2024\n_ = plt.xlim(1980, 2024)\n\n# Adding a grid with customized appearance\n_ = plt.grid(True, linestyle='--', linewidth=0.7, alpha=0.7)\n\n# Enhancing the tick labels for better readability\n_ = plt.xticks(fontsize=20)\n_ = plt.yticks(fontsize=20)\n\n# Adding a light background color to the plot area\nplt.gca().set_facecolor('#f7f7f7')\n\n# Removing the top and right spines for a cleaner look\nsns.despine()\n\n# Adding legend\n_ = plt.legend(fontsize=20)\n\n# Display the plot\nplt.show()\n\n\n\n\n\nplace description here",
    "crumbs": [
      "Chapter 0Ô∏è‚É£",
      "Introduction"
    ]
  },
  {
    "objectID": "index.html#subtitle",
    "href": "index.html#subtitle",
    "title": "Introduction",
    "section": "",
    "text": "More text\n\nü•µ\n\n\n\n\n\nCode\nimport pandas as pd\nimport plotly.express as px\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport seaborn as sns\n\n# Load the cleaned datasets\nhistoric_data_1 = pd.read_csv('./data/clean-data/historic_data_cleaned.csv')\nnearterm_data_1 = pd.read_csv('./data/clean-data/nearterm_data_cleaned.csv')\n\n# Combine datasets for some visualizations\ncombined_data_1 = pd.concat([historic_data_1, nearterm_data_1])\n\n# Calculate the center of the map\ncenter_lat_1 = combined_data_1['lat'].mean()\ncenter_long_1 = combined_data_1['long'].mean()\n\n# Function to calculate an appropriate zoom level based on the spread of data points\ndef calculate_zoom_level_1(latitudes_1, longitudes_1):\n    max_lat_1, min_lat_1 = np.max(latitudes_1), np.min(latitudes_1)\n    max_long_1, min_long_1 = np.max(longitudes_1), np.min(longitudes_1)\n    lat_diff_1 = max_lat_1 - min_lat_1\n    long_diff_1 = max_long_1 - min_long_1\n    max_diff_1 = max(lat_diff_1, long_diff_1)\n    \n    if max_diff_1 &lt; 0.01:\n        return 15\n    elif max_diff_1 &lt; 0.1:\n        return 12\n    elif max_diff_1 &lt; 1:\n        return 10\n    elif max_diff_1 &lt; 10:\n        return 8\n    else:\n        return 6\n\n# Calculate zoom level (but we will manually adjust it for more zoom)\nzoom_level_1 = calculate_zoom_level_1(combined_data_1['lat'], combined_data_1['long'])\n\n# Manually adjust zoom level for a more zoomed-in view\nzoom_level_1 = zoom_level_1 * 0.95  # Increase the zoom factor\n\n# Set Mapbox access token\npx.set_mapbox_access_token(\"pk.eyJ1IjoiaXNmYXJiYXNldCIsImEiOiJjbHdiOWVtY2IwbGxsMmtraHZoYnB1YTMwIn0.10XSE1rNVsmXSnFmYYa0Cw\")\n\n# Create the Plotly scatter_mapbox map with enhanced aesthetics and detailed map layers\nmap_fig_1 = px.scatter_mapbox(combined_data_1, lon='long', lat='lat', color='Tmax_Summer',\n                            hover_data={'Tmax_Summer': ':.2f', 'lat': ':.2f', 'long': ':.2f', 'year': True}, size='Tmax_Summer',\n                            labels={'Tmax_Summer': 'max temp', 'lat': 'latitude', 'long': 'longitude'},\n                            animation_frame='year', title='Geospatial Distribution of Maximum Temperature Over Time',\n                            color_continuous_scale=px.colors.sequential.Sunsetdark, size_max=15, zoom=zoom_level_1,\n                            center={\"lat\": center_lat_1, \"lon\": center_long_1}\n                            )\n\n# Update the layout for better aesthetics and visibility of state lines\nmap_fig_1.update_layout(\n    mapbox_style=\"carto-positron\",  # Change the map style to show more details\n    mapbox=dict(\n        center=dict(lat=center_lat_1, lon=center_long_1),\n        zoom=zoom_level_1,  # Adjusted zoom level\n    ),\n    title_font=dict(size=18, family='Arial, sans-serif'),  \n    title_x=0.5,\n    coloraxis_colorbar=dict(\n        title=\"Maximum Temperature(¬∞C)\",\n        title_side=\"right\",  # Align the title horizontally with the colorbar\n        title_font=dict(size=14)  # Adjust the font size as needed\n    ),\n    autosize=True,\n    width=750,  # Increase the width of the map\n    height=700   # Increase the height of the map\n)\n\n\n                        \n                                            \nplace description here\n\n\nCode\n# Extracting the relevant column for analysis\nhistoric_tmax_data = historic_data_1[['year', 'Tmax_Summer']]\nnearterm_tmax_data = nearterm_data_1[['year', 'Tmax_Summer']]\n\n# Merging both datasets for a comprehensive analysis\ncombined_tmax_data = pd.concat([historic_tmax_data, nearterm_tmax_data])\n\n# Aggregating the data by year using the mean\ncombined_tmax_data_aggregated = combined_tmax_data.groupby('year').mean().reset_index()\n\n# Setting the style of the plot\nsns.set_theme(style=\"whitegrid\")\n\n# Plotting the Tmax_Summer over the years with enhancements and a trendline\nplt.figure(figsize=(16, 9))\nsns.lineplot(data=combined_tmax_data_aggregated, x='year', y='Tmax_Summer', marker='o', color='maroon', linewidth=2.5, label='Maximum Summer Temperature')\nsns.regplot(data=combined_tmax_data_aggregated, x='year', y='Tmax_Summer', scatter=False, color='red', ci=None, line_kws={\"linewidth\":2.5, \"linestyle\":\"--\"}, label='Trendline')\n\n# Adding titles and labels with enhanced aesthetics\nplt.title('Maximum Temperature Trend\\n in Southeastern Utah', fontsize=32)\nplt.xlabel('Year', fontsize=25, weight='bold')\nplt.ylabel('Maximum Temperature (¬∞C)', fontsize=25, weight='bold')\n\n# Setting the x-axis range from 1980 to 2024\n_ = plt.xlim(1980, 2024)\n\n# Adding a grid with customized appearance\n_ = plt.grid(True, linestyle='--', linewidth=0.7, alpha=0.7)\n\n# Enhancing the tick labels for better readability\n_ = plt.xticks(fontsize=20)\n_ = plt.yticks(fontsize=20)\n\n# Adding a light background color to the plot area\nplt.gca().set_facecolor('#f7f7f7')\n\n# Removing the top and right spines for a cleaner look\nsns.despine()\n\n# Adding legend\n_ = plt.legend(fontsize=20)\n\n# Display the plot\nplt.show()\n\n\n\n\n\nplace description here",
    "crumbs": [
      "Chapter 0Ô∏è‚É£",
      "Introduction"
    ]
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site"
  },
  {
    "objectID": "trend.html",
    "href": "trend.html",
    "title": "Trend Analysis",
    "section": "",
    "text": "Text here\n\n\nCode\nlibrary(reticulate)\n\nuse_condaenv(\"base\", required = TRUE)\n\n\n\n\nMore text\n\n\n\n\nCode\nimport pandas as pd\nimport plotly.express as px\nimport plotly.graph_objects as go\nimport numpy as np\nfrom sklearn.linear_model import LinearRegression\n\n# Load the cleaned datasets\nhistoric_data = pd.read_csv('./data/clean-data/historic_data_cleaned.csv')\nnearterm_data = pd.read_csv('./data/clean-data/nearterm_data_cleaned.csv')\n\n# Combine datasets for some visualizations\ncombined_data = pd.concat([historic_data, nearterm_data])\n\n# Prepare data for linear regression\ncombined_precip = combined_data.dropna(subset=['PPT_Annual'])\nX_precip = combined_precip[['year']].values\ny_precip = combined_precip['PPT_Annual'].values\n\n# Prepare data for linear regression\ncombined_temp = combined_data.dropna(subset=['T_Annual'])\nX_temp = combined_temp[['year']].values\ny_temp = combined_temp['T_Annual'].values\n\n# Aggregate data by year for temperature and precipitation\naggregated_temp = combined_temp.groupby('year').mean().reset_index()\naggregated_precip = combined_precip.groupby('year').mean().reset_index()\n\n# Linear regression analysis for aggregated temperature data\nX_temp_agg = aggregated_temp[['year']].values\ny_temp_agg = aggregated_temp['T_Annual'].values\nmodel_temp_agg = LinearRegression().fit(X_temp_agg, y_temp_agg)\ntrend_temp_agg = model_temp_agg.predict(X_temp_agg)\nslope_temp_agg = model_temp_agg.coef_[0]\nintercept_temp_agg = model_temp_agg.intercept_\n\n# Create the figure for temperature trend\nfig_temp = go.Figure(data=[\n    go.Scatter(\n        x=aggregated_temp['year'], \n        y=aggregated_temp['T_Annual'],\n        mode='markers+lines',\n        name='Observed',\n        hovertemplate='Year: %{x}&lt;br&gt;Avg Temp: %{y:.2f}¬∞C'\n    ),\n    go.Scatter(\n        x=aggregated_temp['year'], \n        y=trend_temp_agg,\n        mode='lines',\n        name='Trend',\n        line=dict(color='red'),\n        hovertemplate='Year: %{x}&lt;br&gt;Trend: %{y:.2f}¬∞C'\n    )\n])\n\n# Update layout for temperature trend\nfig_temp.update_layout(\n    title='Trend Analysis: Average Annual Temperature in Utah (1980-2024)',\n    xaxis_title='Year',\n    yaxis_title='Average Temperature (¬∞C)',\n    legend_title='',\n    template='plotly_white'\n)\n\n\n                        \n                                            \nplace description here\n\n\nCode\n# Linear regression analysis for aggregated precipitation data with the full range of years\nall_years = pd.DataFrame({'year': np.arange(aggregated_precip['year'].min(), aggregated_precip['year'].max() + 1)})\naggregated_precip_full = pd.merge(all_years, aggregated_precip, on='year', how='left')\n\nX_precip_agg_full = aggregated_precip_full[['year']].values\ny_precip_agg_full = aggregated_precip_full['PPT_Annual'].values\nmodel_precip_agg_full = LinearRegression().fit(X_precip_agg_full[~np.isnan(y_precip_agg_full)], \n                                               y_precip_agg_full[~np.isnan(y_precip_agg_full)])\ntrend_precip_agg_full = model_precip_agg_full.predict(X_precip_agg_full)\n\n# Create the figure for precipitation trend with line plot\nfig_precip = go.Figure(data=[\n    go.Scatter(\n        x=aggregated_precip_full['year'], \n        y=aggregated_precip_full['PPT_Annual'],\n        mode='markers+lines',\n        name='Observed',\n        line=dict(color='skyblue'),\n        hovertemplate='Year: %{x}&lt;br&gt;Total Precip: %{y:.2f} inches'\n    ),\n    go.Scatter(\n        x=aggregated_precip_full['year'], \n        y=trend_precip_agg_full,\n        mode='lines',\n        name='Trend',\n        line=dict(color='red'),\n        hovertemplate='Year: %{x}&lt;br&gt;Trend: %{y:.2f} inches'\n    )\n])\n\n# Update layout for precipitation trend\nfig_precip.update_layout(\n    title='Trend Analysis: Total Annual Precipitation in Utah (1980-2024)',\n    xaxis_title='Year',\n    yaxis_title='Total Precipitation (inches)',\n    legend_title='',\n    template='plotly_white'\n)\n\n\n                        \n                                            \nplace description here\n\n\nHi my name is Isfar",
    "crumbs": [
      "What's trending üìä",
      "Trend Analysis"
    ]
  },
  {
    "objectID": "trend.html#subtitle",
    "href": "trend.html#subtitle",
    "title": "Trend Analysis",
    "section": "",
    "text": "More text\n\n\n\n\nCode\nimport pandas as pd\nimport plotly.express as px\nimport plotly.graph_objects as go\nimport numpy as np\nfrom sklearn.linear_model import LinearRegression\n\n# Load the cleaned datasets\nhistoric_data = pd.read_csv('./data/clean-data/historic_data_cleaned.csv')\nnearterm_data = pd.read_csv('./data/clean-data/nearterm_data_cleaned.csv')\n\n# Combine datasets for some visualizations\ncombined_data = pd.concat([historic_data, nearterm_data])\n\n# Prepare data for linear regression\ncombined_precip = combined_data.dropna(subset=['PPT_Annual'])\nX_precip = combined_precip[['year']].values\ny_precip = combined_precip['PPT_Annual'].values\n\n# Prepare data for linear regression\ncombined_temp = combined_data.dropna(subset=['T_Annual'])\nX_temp = combined_temp[['year']].values\ny_temp = combined_temp['T_Annual'].values\n\n# Aggregate data by year for temperature and precipitation\naggregated_temp = combined_temp.groupby('year').mean().reset_index()\naggregated_precip = combined_precip.groupby('year').mean().reset_index()\n\n# Linear regression analysis for aggregated temperature data\nX_temp_agg = aggregated_temp[['year']].values\ny_temp_agg = aggregated_temp['T_Annual'].values\nmodel_temp_agg = LinearRegression().fit(X_temp_agg, y_temp_agg)\ntrend_temp_agg = model_temp_agg.predict(X_temp_agg)\nslope_temp_agg = model_temp_agg.coef_[0]\nintercept_temp_agg = model_temp_agg.intercept_\n\n# Create the figure for temperature trend\nfig_temp = go.Figure(data=[\n    go.Scatter(\n        x=aggregated_temp['year'], \n        y=aggregated_temp['T_Annual'],\n        mode='markers+lines',\n        name='Observed',\n        hovertemplate='Year: %{x}&lt;br&gt;Avg Temp: %{y:.2f}¬∞C'\n    ),\n    go.Scatter(\n        x=aggregated_temp['year'], \n        y=trend_temp_agg,\n        mode='lines',\n        name='Trend',\n        line=dict(color='red'),\n        hovertemplate='Year: %{x}&lt;br&gt;Trend: %{y:.2f}¬∞C'\n    )\n])\n\n# Update layout for temperature trend\nfig_temp.update_layout(\n    title='Trend Analysis: Average Annual Temperature in Utah (1980-2024)',\n    xaxis_title='Year',\n    yaxis_title='Average Temperature (¬∞C)',\n    legend_title='',\n    template='plotly_white'\n)\n\n\n                        \n                                            \nplace description here\n\n\nCode\n# Linear regression analysis for aggregated precipitation data with the full range of years\nall_years = pd.DataFrame({'year': np.arange(aggregated_precip['year'].min(), aggregated_precip['year'].max() + 1)})\naggregated_precip_full = pd.merge(all_years, aggregated_precip, on='year', how='left')\n\nX_precip_agg_full = aggregated_precip_full[['year']].values\ny_precip_agg_full = aggregated_precip_full['PPT_Annual'].values\nmodel_precip_agg_full = LinearRegression().fit(X_precip_agg_full[~np.isnan(y_precip_agg_full)], \n                                               y_precip_agg_full[~np.isnan(y_precip_agg_full)])\ntrend_precip_agg_full = model_precip_agg_full.predict(X_precip_agg_full)\n\n# Create the figure for precipitation trend with line plot\nfig_precip = go.Figure(data=[\n    go.Scatter(\n        x=aggregated_precip_full['year'], \n        y=aggregated_precip_full['PPT_Annual'],\n        mode='markers+lines',\n        name='Observed',\n        line=dict(color='skyblue'),\n        hovertemplate='Year: %{x}&lt;br&gt;Total Precip: %{y:.2f} inches'\n    ),\n    go.Scatter(\n        x=aggregated_precip_full['year'], \n        y=trend_precip_agg_full,\n        mode='lines',\n        name='Trend',\n        line=dict(color='red'),\n        hovertemplate='Year: %{x}&lt;br&gt;Trend: %{y:.2f} inches'\n    )\n])\n\n# Update layout for precipitation trend\nfig_precip.update_layout(\n    title='Trend Analysis: Total Annual Precipitation in Utah (1980-2024)',\n    xaxis_title='Year',\n    yaxis_title='Total Precipitation (inches)',\n    legend_title='',\n    template='plotly_white'\n)\n\n\n                        \n                                            \nplace description here\n\n\nHi my name is Isfar",
    "crumbs": [
      "What's trending üìä",
      "Trend Analysis"
    ]
  },
  {
    "objectID": "treecanopy.html",
    "href": "treecanopy.html",
    "title": "Treecanopy Analysis",
    "section": "",
    "text": "Text here\n\n\nCode\nlibrary(reticulate)\n\nuse_condaenv(\"base\", required = TRUE)\n\n\n\n\nMore text\n\n\n\n\nCode\nimport pandas as pd\nimport plotly.express as px\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Load the cleaned datasets\nhistoric_data = pd.read_csv('./data/clean-data/historic_data_cleaned.csv')\nnearterm_data = pd.read_csv('./data/clean-data/nearterm_data_cleaned.csv')\n\n# Combine datasets for some visualizations\ncombined_data = pd.concat([historic_data, nearterm_data])\n\n# Calculate the center of the map\ncenter_lat = combined_data['lat'].mean()\ncenter_long = combined_data['long'].mean()\n\n# Function to calculate an appropriate zoom level based on the spread of data points\ndef calculate_zoom_level(latitudes, longitudes):\n    max_lat, min_lat = np.max(latitudes), np.min(latitudes)\n    max_long, min_long = np.max(longitudes), np.min(longitudes)\n    lat_diff = max_lat - min_lat\n    long_diff = max_long - min_long\n    max_diff = max(lat_diff, long_diff)\n    \n    if max_diff &lt; 0.01:\n        return 15\n    elif max_diff &lt; 0.1:\n        return 12\n    elif max_diff &lt; 1:\n        return 10\n    elif max_diff &lt; 10:\n        return 8\n    else:\n        return 6\n\n# Calculate zoom level (but we will manually adjust it for more zoom)\nzoom_level = calculate_zoom_level(combined_data['lat'], combined_data['long'])\n\n# Manually adjust zoom level for a more zoomed-in view\nzoom_level = zoom_level * 0.95  # Increase the zoom factor\n\n# Create the Plotly scatter_mapbox map with enhanced aesthetics and detailed map layers\nmap_fig = px.scatter_mapbox(combined_data, lon='long', lat='lat', color='treecanopy',\n                            hover_data={'treecanopy': ':.2f', 'lat': ':.2f', 'long': ':.2f', 'year': True}, size='treecanopy',\n                            labels={'treecanopy': 'tree canopy', 'lat': 'latitude', 'long': 'longitude'},\n                            animation_frame='year', title='Geospatial Distribution of Tree Canopy Over Time',\n                            color_continuous_scale=px.colors.sequential.Sunsetdark, size_max=15, zoom=zoom_level,\n                            center={\"lat\": center_lat, \"lon\": center_long})\n\n# Update the layout for better aesthetics and visibility of state lines\nmap_fig.update_layout(\n    mapbox_style=\"carto-positron\",  # Change the map style to show more details\n    mapbox=dict(\n        center=dict(lat=center_lat, lon=center_long),\n        zoom=zoom_level,  # Adjusted zoom level\n    ),\n    title_font=dict(size=18, family='Arial, sans-serif'),  \n    title_x=0.5,\n    coloraxis_colorbar=dict(\n        title=\"Tree Canopy (%)\",\n        title_side=\"right\",  # Align the title horizontally with the colorbar\n        title_font=dict(size=14)  # Adjust the font size as needed\n    ),\n    autosize=True,\n    width=800,  # Increase the width of the map\n    height=700   # Increase the height of the map\n)\n\n\n                        \n                                            \nplace description here\n\n\nHi my name is Isfar",
    "crumbs": [
      "Looking into treecanopy üå≥",
      "Treecanopy Analysis"
    ]
  },
  {
    "objectID": "treecanopy.html#subtitle",
    "href": "treecanopy.html#subtitle",
    "title": "Treecanopy Analysis",
    "section": "",
    "text": "More text\n\n\n\n\nCode\nimport pandas as pd\nimport plotly.express as px\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Load the cleaned datasets\nhistoric_data = pd.read_csv('./data/clean-data/historic_data_cleaned.csv')\nnearterm_data = pd.read_csv('./data/clean-data/nearterm_data_cleaned.csv')\n\n# Combine datasets for some visualizations\ncombined_data = pd.concat([historic_data, nearterm_data])\n\n# Calculate the center of the map\ncenter_lat = combined_data['lat'].mean()\ncenter_long = combined_data['long'].mean()\n\n# Function to calculate an appropriate zoom level based on the spread of data points\ndef calculate_zoom_level(latitudes, longitudes):\n    max_lat, min_lat = np.max(latitudes), np.min(latitudes)\n    max_long, min_long = np.max(longitudes), np.min(longitudes)\n    lat_diff = max_lat - min_lat\n    long_diff = max_long - min_long\n    max_diff = max(lat_diff, long_diff)\n    \n    if max_diff &lt; 0.01:\n        return 15\n    elif max_diff &lt; 0.1:\n        return 12\n    elif max_diff &lt; 1:\n        return 10\n    elif max_diff &lt; 10:\n        return 8\n    else:\n        return 6\n\n# Calculate zoom level (but we will manually adjust it for more zoom)\nzoom_level = calculate_zoom_level(combined_data['lat'], combined_data['long'])\n\n# Manually adjust zoom level for a more zoomed-in view\nzoom_level = zoom_level * 0.95  # Increase the zoom factor\n\n# Create the Plotly scatter_mapbox map with enhanced aesthetics and detailed map layers\nmap_fig = px.scatter_mapbox(combined_data, lon='long', lat='lat', color='treecanopy',\n                            hover_data={'treecanopy': ':.2f', 'lat': ':.2f', 'long': ':.2f', 'year': True}, size='treecanopy',\n                            labels={'treecanopy': 'tree canopy', 'lat': 'latitude', 'long': 'longitude'},\n                            animation_frame='year', title='Geospatial Distribution of Tree Canopy Over Time',\n                            color_continuous_scale=px.colors.sequential.Sunsetdark, size_max=15, zoom=zoom_level,\n                            center={\"lat\": center_lat, \"lon\": center_long})\n\n# Update the layout for better aesthetics and visibility of state lines\nmap_fig.update_layout(\n    mapbox_style=\"carto-positron\",  # Change the map style to show more details\n    mapbox=dict(\n        center=dict(lat=center_lat, lon=center_long),\n        zoom=zoom_level,  # Adjusted zoom level\n    ),\n    title_font=dict(size=18, family='Arial, sans-serif'),  \n    title_x=0.5,\n    coloraxis_colorbar=dict(\n        title=\"Tree Canopy (%)\",\n        title_side=\"right\",  # Align the title horizontally with the colorbar\n        title_font=dict(size=14)  # Adjust the font size as needed\n    ),\n    autosize=True,\n    width=800,  # Increase the width of the map\n    height=700   # Increase the height of the map\n)\n\n\n                        \n                                            \nplace description here\n\n\nHi my name is Isfar",
    "crumbs": [
      "Looking into treecanopy üå≥",
      "Treecanopy Analysis"
    ]
  },
  {
    "objectID": "pages/treecanopy/treecanopy.html",
    "href": "pages/treecanopy/treecanopy.html",
    "title": "Treecanopy Coverage",
    "section": "",
    "text": "Text here\n\n\nCode\nlibrary(reticulate)\n\nuse_condaenv(\"base\", required = TRUE)\n\n\n\n\nMore text\n\n\n\n\nCode\nimport pandas as pd\nimport plotly.express as px\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Load the cleaned datasets\nhistoric_data = pd.read_csv('../../data/clean-data/historic_data_cleaned.csv')\nnearterm_data = pd.read_csv('../../data/clean-data/nearterm_data_cleaned.csv')\n\n# Combine datasets for some visualizations\ncombined_data = pd.concat([historic_data, nearterm_data])\n\n# Calculate the center of the map\ncenter_lat = combined_data['lat'].mean()\ncenter_long = combined_data['long'].mean()\n\n# Function to calculate an appropriate zoom level based on the spread of data points\ndef calculate_zoom_level(latitudes, longitudes):\n    max_lat, min_lat = np.max(latitudes), np.min(latitudes)\n    max_long, min_long = np.max(longitudes), np.min(longitudes)\n    lat_diff = max_lat - min_lat\n    long_diff = max_long - min_long\n    max_diff = max(lat_diff, long_diff)\n    \n    if max_diff &lt; 0.01:\n        return 15\n    elif max_diff &lt; 0.1:\n        return 12\n    elif max_diff &lt; 1:\n        return 10\n    elif max_diff &lt; 10:\n        return 8\n    else:\n        return 6\n\n# Calculate zoom level (but we will manually adjust it for more zoom)\nzoom_level = calculate_zoom_level(combined_data['lat'], combined_data['long'])\n\n# Manually adjust zoom level for a more zoomed-in view\nzoom_level = zoom_level * 0.95  # Increase the zoom factor\n\n# Create the Plotly scatter_mapbox map with enhanced aesthetics and detailed map layers\nmap_fig = px.scatter_mapbox(combined_data, lon='long', lat='lat', color='treecanopy',\n                            hover_data={'treecanopy': ':.2f', 'lat': ':.2f', 'long': ':.2f', 'year': True}, size='treecanopy',\n                            labels={'treecanopy': 'tree canopy', 'lat': 'latitude', 'long': 'longitude'},\n                            animation_frame='year', title='Geospatial Distribution of Tree Canopy Over Time',\n                            color_continuous_scale=px.colors.sequential.Sunsetdark, size_max=15, zoom=zoom_level,\n                            center={\"lat\": center_lat, \"lon\": center_long})\n\n# Update the layout for better aesthetics and visibility of state lines\nmap_fig.update_layout(\n    mapbox_style=\"carto-positron\",  # Change the map style to show more details\n    mapbox=dict(\n        center=dict(lat=center_lat, lon=center_long),\n        zoom=zoom_level,  # Adjusted zoom level\n    ),\n    title_font=dict(size=18, family='Arial, sans-serif'),  \n    title_x=0.5,\n    coloraxis_colorbar=dict(\n        title=\"Tree Canopy (%)\",\n        title_side=\"right\",  # Align the title horizontally with the colorbar\n        title_font=dict(size=14)  # Adjust the font size as needed\n    ),\n    autosize=True,\n    width=800,  # Increase the width of the map\n    height=700   # Increase the height of the map\n)\n\n\n                        \n                                            \nplace description here\n\n\nHi my name is Isfar",
    "crumbs": [
      "2Ô∏è‚É£",
      "Treecanopy Coverage"
    ]
  },
  {
    "objectID": "pages/treecanopy/treecanopy.html#subtitle",
    "href": "pages/treecanopy/treecanopy.html#subtitle",
    "title": "Treecanopy Coverage",
    "section": "",
    "text": "More text\n\n\n\n\nCode\nimport pandas as pd\nimport plotly.express as px\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Load the cleaned datasets\nhistoric_data = pd.read_csv('../../data/clean-data/historic_data_cleaned.csv')\nnearterm_data = pd.read_csv('../../data/clean-data/nearterm_data_cleaned.csv')\n\n# Combine datasets for some visualizations\ncombined_data = pd.concat([historic_data, nearterm_data])\n\n# Calculate the center of the map\ncenter_lat = combined_data['lat'].mean()\ncenter_long = combined_data['long'].mean()\n\n# Function to calculate an appropriate zoom level based on the spread of data points\ndef calculate_zoom_level(latitudes, longitudes):\n    max_lat, min_lat = np.max(latitudes), np.min(latitudes)\n    max_long, min_long = np.max(longitudes), np.min(longitudes)\n    lat_diff = max_lat - min_lat\n    long_diff = max_long - min_long\n    max_diff = max(lat_diff, long_diff)\n    \n    if max_diff &lt; 0.01:\n        return 15\n    elif max_diff &lt; 0.1:\n        return 12\n    elif max_diff &lt; 1:\n        return 10\n    elif max_diff &lt; 10:\n        return 8\n    else:\n        return 6\n\n# Calculate zoom level (but we will manually adjust it for more zoom)\nzoom_level = calculate_zoom_level(combined_data['lat'], combined_data['long'])\n\n# Manually adjust zoom level for a more zoomed-in view\nzoom_level = zoom_level * 0.95  # Increase the zoom factor\n\n# Create the Plotly scatter_mapbox map with enhanced aesthetics and detailed map layers\nmap_fig = px.scatter_mapbox(combined_data, lon='long', lat='lat', color='treecanopy',\n                            hover_data={'treecanopy': ':.2f', 'lat': ':.2f', 'long': ':.2f', 'year': True}, size='treecanopy',\n                            labels={'treecanopy': 'tree canopy', 'lat': 'latitude', 'long': 'longitude'},\n                            animation_frame='year', title='Geospatial Distribution of Tree Canopy Over Time',\n                            color_continuous_scale=px.colors.sequential.Sunsetdark, size_max=15, zoom=zoom_level,\n                            center={\"lat\": center_lat, \"lon\": center_long})\n\n# Update the layout for better aesthetics and visibility of state lines\nmap_fig.update_layout(\n    mapbox_style=\"carto-positron\",  # Change the map style to show more details\n    mapbox=dict(\n        center=dict(lat=center_lat, lon=center_long),\n        zoom=zoom_level,  # Adjusted zoom level\n    ),\n    title_font=dict(size=18, family='Arial, sans-serif'),  \n    title_x=0.5,\n    coloraxis_colorbar=dict(\n        title=\"Tree Canopy (%)\",\n        title_side=\"right\",  # Align the title horizontally with the colorbar\n        title_font=dict(size=14)  # Adjust the font size as needed\n    ),\n    autosize=True,\n    width=800,  # Increase the width of the map\n    height=700   # Increase the height of the map\n)\n\n\n                        \n                                            \nplace description here\n\n\nHi my name is Isfar",
    "crumbs": [
      "2Ô∏è‚É£",
      "Treecanopy Coverage"
    ]
  },
  {
    "objectID": "pages/trend/trend.html",
    "href": "pages/trend/trend.html",
    "title": "Trend Analysis",
    "section": "",
    "text": "Text here\n\n\nCode\nlibrary(reticulate)\n\nuse_condaenv(\"base\", required = TRUE)\n\n\n\n\nMore text\n\n\n\n\nCode\nimport pandas as pd\nimport plotly.express as px\nimport plotly.graph_objects as go\nimport numpy as np\nfrom sklearn.linear_model import LinearRegression\n\n# Load the cleaned datasets\nhistoric_data = pd.read_csv('../../data/clean-data/historic_data_cleaned.csv')\nnearterm_data = pd.read_csv('../../data/clean-data/nearterm_data_cleaned.csv')\n\n# Combine datasets for some visualizations\ncombined_data = pd.concat([historic_data, nearterm_data])\n\n# Prepare data for linear regression\ncombined_precip = combined_data.dropna(subset=['PPT_Annual'])\nX_precip = combined_precip[['year']].values\ny_precip = combined_precip['PPT_Annual'].values\n\n# Prepare data for linear regression\ncombined_temp = combined_data.dropna(subset=['T_Annual'])\nX_temp = combined_temp[['year']].values\ny_temp = combined_temp['T_Annual'].values\n\n# Aggregate data by year for temperature and precipitation\naggregated_temp = combined_temp.groupby('year').mean().reset_index()\naggregated_precip = combined_precip.groupby('year').mean().reset_index()\n\n# Linear regression analysis for aggregated temperature data\nX_temp_agg = aggregated_temp[['year']].values\ny_temp_agg = aggregated_temp['T_Annual'].values\nmodel_temp_agg = LinearRegression().fit(X_temp_agg, y_temp_agg)\ntrend_temp_agg = model_temp_agg.predict(X_temp_agg)\nslope_temp_agg = model_temp_agg.coef_[0]\nintercept_temp_agg = model_temp_agg.intercept_\n\n# Create the figure for temperature trend\nfig_temp = go.Figure(data=[\n    go.Scatter(\n        x=aggregated_temp['year'], \n        y=aggregated_temp['T_Annual'],\n        mode='markers+lines',\n        name='Observed',\n        hovertemplate='Year: %{x}&lt;br&gt;Avg Temp: %{y:.2f}¬∞C'\n    ),\n    go.Scatter(\n        x=aggregated_temp['year'], \n        y=trend_temp_agg,\n        mode='lines',\n        name='Trend',\n        line=dict(color='red'),\n        hovertemplate='Year: %{x}&lt;br&gt;Trend: %{y:.2f}¬∞C'\n    )\n])\n\n# Update layout for temperature trend\nfig_temp.update_layout(\n    title='Trend Analysis: Average Annual Temperature in Utah (1980-2024)',\n    xaxis_title='Year',\n    yaxis_title='Average Temperature (¬∞C)',\n    legend_title='',\n    template='plotly_white'\n)\n\n\n                        \n                                            \nplace description here\n\n\nCode\n# Linear regression analysis for aggregated precipitation data with the full range of years\nall_years = pd.DataFrame({'year': np.arange(aggregated_precip['year'].min(), aggregated_precip['year'].max() + 1)})\naggregated_precip_full = pd.merge(all_years, aggregated_precip, on='year', how='left')\n\nX_precip_agg_full = aggregated_precip_full[['year']].values\ny_precip_agg_full = aggregated_precip_full['PPT_Annual'].values\nmodel_precip_agg_full = LinearRegression().fit(X_precip_agg_full[~np.isnan(y_precip_agg_full)], \n                                               y_precip_agg_full[~np.isnan(y_precip_agg_full)])\ntrend_precip_agg_full = model_precip_agg_full.predict(X_precip_agg_full)\n\n# Create the figure for precipitation trend with line plot\nfig_precip = go.Figure(data=[\n    go.Scatter(\n        x=aggregated_precip_full['year'], \n        y=aggregated_precip_full['PPT_Annual'],\n        mode='markers+lines',\n        name='Observed',\n        line=dict(color='skyblue'),\n        hovertemplate='Year: %{x}&lt;br&gt;Total Precip: %{y:.2f} inches'\n    ),\n    go.Scatter(\n        x=aggregated_precip_full['year'], \n        y=trend_precip_agg_full,\n        mode='lines',\n        name='Trend',\n        line=dict(color='red'),\n        hovertemplate='Year: %{x}&lt;br&gt;Trend: %{y:.2f} inches'\n    )\n])\n\n# Update layout for precipitation trend\nfig_precip.update_layout(\n    title='Trend Analysis: Total Annual Precipitation in Utah (1980-2024)',\n    xaxis_title='Year',\n    yaxis_title='Total Precipitation (inches)',\n    legend_title='',\n    template='plotly_white'\n)\n\n\n                        \n                                            \nplace description here\n\n\nHi my name is Isfar",
    "crumbs": [
      "3Ô∏è‚É£",
      "Trend Analysis"
    ]
  },
  {
    "objectID": "pages/trend/trend.html#subtitle",
    "href": "pages/trend/trend.html#subtitle",
    "title": "Trend Analysis",
    "section": "",
    "text": "More text\n\n\n\n\nCode\nimport pandas as pd\nimport plotly.express as px\nimport plotly.graph_objects as go\nimport numpy as np\nfrom sklearn.linear_model import LinearRegression\n\n# Load the cleaned datasets\nhistoric_data = pd.read_csv('../../data/clean-data/historic_data_cleaned.csv')\nnearterm_data = pd.read_csv('../../data/clean-data/nearterm_data_cleaned.csv')\n\n# Combine datasets for some visualizations\ncombined_data = pd.concat([historic_data, nearterm_data])\n\n# Prepare data for linear regression\ncombined_precip = combined_data.dropna(subset=['PPT_Annual'])\nX_precip = combined_precip[['year']].values\ny_precip = combined_precip['PPT_Annual'].values\n\n# Prepare data for linear regression\ncombined_temp = combined_data.dropna(subset=['T_Annual'])\nX_temp = combined_temp[['year']].values\ny_temp = combined_temp['T_Annual'].values\n\n# Aggregate data by year for temperature and precipitation\naggregated_temp = combined_temp.groupby('year').mean().reset_index()\naggregated_precip = combined_precip.groupby('year').mean().reset_index()\n\n# Linear regression analysis for aggregated temperature data\nX_temp_agg = aggregated_temp[['year']].values\ny_temp_agg = aggregated_temp['T_Annual'].values\nmodel_temp_agg = LinearRegression().fit(X_temp_agg, y_temp_agg)\ntrend_temp_agg = model_temp_agg.predict(X_temp_agg)\nslope_temp_agg = model_temp_agg.coef_[0]\nintercept_temp_agg = model_temp_agg.intercept_\n\n# Create the figure for temperature trend\nfig_temp = go.Figure(data=[\n    go.Scatter(\n        x=aggregated_temp['year'], \n        y=aggregated_temp['T_Annual'],\n        mode='markers+lines',\n        name='Observed',\n        hovertemplate='Year: %{x}&lt;br&gt;Avg Temp: %{y:.2f}¬∞C'\n    ),\n    go.Scatter(\n        x=aggregated_temp['year'], \n        y=trend_temp_agg,\n        mode='lines',\n        name='Trend',\n        line=dict(color='red'),\n        hovertemplate='Year: %{x}&lt;br&gt;Trend: %{y:.2f}¬∞C'\n    )\n])\n\n# Update layout for temperature trend\nfig_temp.update_layout(\n    title='Trend Analysis: Average Annual Temperature in Utah (1980-2024)',\n    xaxis_title='Year',\n    yaxis_title='Average Temperature (¬∞C)',\n    legend_title='',\n    template='plotly_white'\n)\n\n\n                        \n                                            \nplace description here\n\n\nCode\n# Linear regression analysis for aggregated precipitation data with the full range of years\nall_years = pd.DataFrame({'year': np.arange(aggregated_precip['year'].min(), aggregated_precip['year'].max() + 1)})\naggregated_precip_full = pd.merge(all_years, aggregated_precip, on='year', how='left')\n\nX_precip_agg_full = aggregated_precip_full[['year']].values\ny_precip_agg_full = aggregated_precip_full['PPT_Annual'].values\nmodel_precip_agg_full = LinearRegression().fit(X_precip_agg_full[~np.isnan(y_precip_agg_full)], \n                                               y_precip_agg_full[~np.isnan(y_precip_agg_full)])\ntrend_precip_agg_full = model_precip_agg_full.predict(X_precip_agg_full)\n\n# Create the figure for precipitation trend with line plot\nfig_precip = go.Figure(data=[\n    go.Scatter(\n        x=aggregated_precip_full['year'], \n        y=aggregated_precip_full['PPT_Annual'],\n        mode='markers+lines',\n        name='Observed',\n        line=dict(color='skyblue'),\n        hovertemplate='Year: %{x}&lt;br&gt;Total Precip: %{y:.2f} inches'\n    ),\n    go.Scatter(\n        x=aggregated_precip_full['year'], \n        y=trend_precip_agg_full,\n        mode='lines',\n        name='Trend',\n        line=dict(color='red'),\n        hovertemplate='Year: %{x}&lt;br&gt;Trend: %{y:.2f} inches'\n    )\n])\n\n# Update layout for precipitation trend\nfig_precip.update_layout(\n    title='Trend Analysis: Total Annual Precipitation in Utah (1980-2024)',\n    xaxis_title='Year',\n    yaxis_title='Total Precipitation (inches)',\n    legend_title='',\n    template='plotly_white'\n)\n\n\n                        \n                                            \nplace description here\n\n\nHi my name is Isfar",
    "crumbs": [
      "3Ô∏è‚É£",
      "Trend Analysis"
    ]
  },
  {
    "objectID": "pages/soil/soil.html",
    "href": "pages/soil/soil.html",
    "title": "Soil in Summer",
    "section": "",
    "text": "Code\nimport pandas as pd\nimport plotly.express as px\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport pandas as pd\nimport plotly.graph_objects as go\nimport seaborn as sns\n\n\n\n\nCode\n# Load the cleaned datasets\nhistoric_data = pd.read_csv('../../data/clean-data/historic_data_cleaned.csv')\nnearterm_data = pd.read_csv('../../data/clean-data/nearterm_data_cleaned.csv')\n\n# Combine datasets for some visualizations\ncombined_data = pd.concat([historic_data, nearterm_data])\n\n\n\n\nCode\n# Group by year and calculate the average values for Tmax_Summer and VWC_Summer_whole\naverage_data = combined_data.groupby('year').agg({'Tmax_Summer': 'mean', 'VWC_Summer_whole': 'mean'}).reset_index()\n\n# Create the scatter plot to show the relationship between Tmax_Summer and VWC_Summer_whole\nfig = px.scatter(average_data, x='Tmax_Summer', y='VWC_Summer_whole',\n                 trendline='ols',  # Add a trendline\n                 title='Relationship Between Summer Maximum Temperature and Soil Moisture',\n                 labels={'Tmax_Summer': 'Maximum Summer Temperature (¬∞C)', 'VWC_Summer_whole': 'Average Soil Moisture (%)'})\n\n# Update layout for better aesthetics\nfig.update_layout(\n    title_font=dict(size=18, family='Arial, sans-serif'),\n    xaxis_title='Maximum Summer Temperature (¬∞C)',\n    yaxis_title='Average Soil Moisture (%)',\n    width=800,\n    height=600\n)\n\n# Show the plot\nfig.show()\n\n\nUnable to display output for mime type(s): application/vnd.plotly.v1+json\n\n\n\n\nCode\n# Extracting the relevant column for analysis\nhistoric_soil_data = historic_data[['year', 'VWC_Summer_whole']]\nnearterm_soil_data = nearterm_data[['year', 'VWC_Summer_whole']]\n\n# Merging both datasets for a comprehensive analysis\ncombined_soil_data = pd.concat([historic_soil_data, nearterm_soil_data])\n\n# Aggregating the data by year using the mean\ncombined_soil_data_aggregated = combined_soil_data.groupby('year').mean().reset_index()\n\n# Plotting the NonDrySWA in Summer trend over the years\nplt.figure(figsize=(10, 6))\nsns.lineplot(data=combined_soil_data_aggregated, x='year', y='VWC_Summer_whole', marker='o', color='brown')\nplt.title('Soil moisture in Summer Trend')\nplt.xlabel('Year')\nplt.ylabel('NonDrySWA in Summer')\nplt.grid(True)\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\nCode\n# Extracting the relevant column for analysis\nhistoric_soil_data = historic_data[['year', 'DrySoilDays_Summer_whole']]\nnearterm_soil_data = nearterm_data[['year', 'DrySoilDays_Summer_whole']]\n\n# Merging both datasets for a comprehensive analysis\ncombined_soil_data = pd.concat([historic_soil_data, nearterm_soil_data])\n\n# Aggregating the data by year using the mean\ncombined_soil_data_aggregated = combined_soil_data.groupby('year').mean().reset_index()\n\n# Plotting the NonDrySWA in Summer trend over the years\nplt.figure(figsize=(10, 6))\nsns.lineplot(data=combined_soil_data_aggregated, x='year', y='DrySoilDays_Summer_whole', marker='o', color='brown')\nplt.title('Dry soil in Summer Trend')\nplt.xlabel('Year')\nplt.ylabel('NonDrySWA in Summer')\nplt.grid(True)\nplt.show()",
    "crumbs": [
      "2Ô∏è‚É£",
      "Soil in Summer"
    ]
  },
  {
    "objectID": "pages/ppt/ppt.html",
    "href": "pages/ppt/ppt.html",
    "title": "Precipitation",
    "section": "",
    "text": "Code\nimport pandas as pd\nimport plotly.express as px\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport pandas as pd\nimport plotly.graph_objects as go\nimport seaborn as sns\n\n\n\n\nCode\n# Load the cleaned datasets\nhistoric_data = pd.read_csv('../../data/clean-data/historic_data_cleaned.csv')\nnearterm_data = pd.read_csv('../../data/clean-data/nearterm_data_cleaned.csv')\n\n# Combine datasets for some visualizations\ncombined_data = pd.concat([historic_data, nearterm_data])\n\n\n\n\nCode\n# Extracting the relevant column for analysis\nhistoric_ppt_data = historic_data[['year', 'PPT_Summer']]\nnearterm_ppt_data = nearterm_data[['year', 'PPT_Summer']]\n\n# Merging both datasets for a comprehensive analysis\ncombined_ppt_data = pd.concat([historic_ppt_data, nearterm_ppt_data])\n\n# Aggregating the data by year using the mean\ncombined_soil_data_aggregated = combined_ppt_data.groupby('year').mean().reset_index()\n\n# Plotting the PPT_Summer over the years\nplt.figure(figsize=(10, 6))\nsns.lineplot(data=combined_ppt_data, x='year', y='PPT_Summer', marker='o', color='cyan')\nplt.title('Summer Precipitation Trend')\nplt.xlabel('Year')\nplt.ylabel('Summer Precipitation (inches)')\nplt.grid(True)\nplt.show()",
    "crumbs": [
      "4Ô∏è‚É£",
      "Precipitation"
    ]
  },
  {
    "objectID": "pages/evaporation/evap.html",
    "href": "pages/evaporation/evap.html",
    "title": "Evaporation",
    "section": "",
    "text": "Code\nimport pandas as pd\nimport plotly.express as px\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport pandas as pd\nimport plotly.graph_objects as go\nimport seaborn as sns\n\n\n\n\nCode\n# Load the cleaned datasets\nhistoric_data = pd.read_csv('../../data/clean-data/historic_data_cleaned.csv')\nnearterm_data = pd.read_csv('../../data/clean-data/nearterm_data_cleaned.csv')\n\n# Combine datasets for some visualizations\ncombined_data = pd.concat([historic_data, nearterm_data])\n\n\n\n\nCode\n# Extracting the relevant column for analysis\nhistoric_evap_data = historic_data[['year', 'Evap_Summer']]\nnearterm_evap_data = nearterm_data[['year', 'Evap_Summer']]\n\n# Merging both datasets for a comprehensive analysis\ncombined_evap_data = pd.concat([historic_evap_data, nearterm_evap_data])\n\n# Aggregating the data by year using the mean\ncombined_evap_data_aggregated = combined_evap_data.groupby('year').mean().reset_index()\n\n# Plotting the Evaporation in Summer trend over the years\nplt.figure(figsize=(10, 6))\nsns.lineplot(data=combined_evap_data_aggregated, x='year', y='Evap_Summer', marker='o', color='orange')\nplt.title('Evaporation in Summer Trend')\nplt.xlabel('Year')\nplt.ylabel('Evaporation in Summer')\nplt.grid(True)\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\nCode\n# Extracting the relevant column for analysis\nhistoric_dry_stress_data = historic_data[['year', 'ExtremeShortTermDryStress_Summer_whole']]\nnearterm_dry_stress_data = nearterm_data[['year', 'ExtremeShortTermDryStress_Summer_whole']]\n\n# Merging both datasets for a comprehensive analysis\ncombined_dry_stress_data = pd.concat([historic_dry_stress_data, nearterm_dry_stress_data])\n\n# Aggregating the data by year using the mean\ncombined_dry_stress_data_aggregated = combined_dry_stress_data.groupby('year').mean().reset_index()\n\n# Plotting the Extreme Short Term Dry Stress in Summer trend over the years\nplt.figure(figsize=(10, 6))\nsns.lineplot(data=combined_dry_stress_data_aggregated, x='year', y='ExtremeShortTermDryStress_Summer_whole', marker='o', color='red')\nplt.title('Extreme Short Term Dry Stress in Summer Trend')\nplt.xlabel('Year')\nplt.ylabel('Extreme Short Term Dry Stress in Summer')\nplt.grid(True)\nplt.show()",
    "crumbs": [
      "3Ô∏è‚É£",
      "Evaporation"
    ]
  },
  {
    "objectID": "soil.html",
    "href": "soil.html",
    "title": "Summer Soil",
    "section": "",
    "text": "Text here\n\n\nCode\nlibrary(reticulate)\n\nuse_condaenv(\"base\", required = TRUE)\n\n\n\n\nMore text\n\nüçÇ\n\n\n\n\n\nCode\nimport pandas as pd\nimport plotly.express as px\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport pandas as pd\nimport plotly.graph_objects as go\nimport seaborn as sns\nfrom sklearn.linear_model import LinearRegression\n\n# Load the cleaned datasets\nhistoric_data = pd.read_csv('./data/clean-data/historic_data_cleaned.csv')\nnearterm_data = pd.read_csv('./data/clean-data/nearterm_data_cleaned.csv')\n\n# Combine datasets for some visualizations\ncombined_data = pd.concat([historic_data, nearterm_data])\n\n# Group by year and calculate the average values for Tmax_Summer and VWC_Summer_whole\naverage_data = combined_data.groupby('year').agg({'Tmax_Summer': 'mean', 'VWC_Summer_whole': 'mean'}).reset_index()\n\n# Create the scatter plot to show the relationship between Tmax_Summer and VWC_Summer_whole\nfig = px.scatter(average_data, x='Tmax_Summer', y='VWC_Summer_whole',\n                 trendline='ols',  # Add a trendline\n                 title='Relationship Between Summer Maximum Temperature and Soil Moisture',\n                 labels={'Tmax_Summer': 'Maximum Summer Temperature (¬∞C)', 'VWC_Summer_whole': 'Average Soil Moisture (%)'})\n\n# Update layout for better aesthetics\nfig.update_layout(\n    title_font=dict(size=18, family='Arial, sans-serif'),\n    xaxis_title='Maximum Summer Temperature (¬∞C)',\n    yaxis_title='Average Soil Moisture (%)',\n    width=800,\n    height=600\n)\n\n\n                        \n                                            \nplace description here\n\n\nCode\n# Extracting the relevant column for VWC_Summer_whole analysis\nhistoric_soil_data_vwc = historic_data[['year', 'VWC_Summer_whole']]\nnearterm_soil_data_vwc = nearterm_data[['year', 'VWC_Summer_whole']]\ncombined_soil_data_vwc = pd.concat([historic_soil_data_vwc, nearterm_soil_data_vwc])\ncombined_soil_data_vwc_aggregated = combined_soil_data_vwc.groupby('year').mean().reset_index()\n\n# Extracting the relevant column for DrySoilDays_Summer_whole analysis\nhistoric_soil_data_dry = historic_data[['year', 'DrySoilDays_Summer_whole']]\nnearterm_soil_data_dry = nearterm_data[['year', 'DrySoilDays_Summer_whole']]\ncombined_soil_data_dry = pd.concat([historic_soil_data_dry, nearterm_soil_data_dry])\ncombined_soil_data_dry_aggregated = combined_soil_data_dry.groupby('year').mean().reset_index()\n\n# Function to calculate trendline\ndef calculate_trendline(x, y):\n    model = LinearRegression()\n    x_reshaped = np.array(x).reshape(-1, 1)\n    model.fit(x_reshaped, y)\n    trend = model.predict(x_reshaped)\n    return trend\n\n# Calculate trendline for VWC_Summer_whole\nvwc_trend = calculate_trendline(combined_soil_data_vwc_aggregated['year'], combined_soil_data_vwc_aggregated['VWC_Summer_whole'])\n\n# Determine the y-axis range to better show changes in moisture levels\ny_min = combined_soil_data_vwc_aggregated['VWC_Summer_whole'].min() - 0.005\ny_max = combined_soil_data_vwc_aggregated['VWC_Summer_whole'].max() + 0.005\n\n# Create the first area chart for VWC_Summer_whole with trendline\nfig1 = go.Figure(\n    data=[\n        go.Scatter(\n            x=combined_soil_data_vwc_aggregated['year'],\n            y=combined_soil_data_vwc_aggregated['VWC_Summer_whole'],\n            fill='tozeroy',\n            name='Soil Moisture in Summer',\n            mode='none',\n            fillcolor='#003c54'\n        ),\n        go.Scatter(\n            x=combined_soil_data_vwc_aggregated['year'],\n            y=vwc_trend,\n            mode='lines',\n            name='Trendline',\n            line=dict(color='red', dash='dash')\n        )\n    ],\n    layout=dict(\n        title='Soil Moisture in Summer Trend',\n        xaxis_title='Year',\n        yaxis_title='Soil Moisture (%)',\n        yaxis=dict(range=[y_min, y_max], tickfont=dict(size=14)),  # Set the y-axis range\n        title_font=dict(size=18, family='Arial, sans-serif'),\n        xaxis=dict(tickfont=dict(size=14)),\n        width=800,\n        height=600,\n        plot_bgcolor='#f7f7f7',\n        hoverlabel=dict(font_size=16),\n        showlegend=True,\n        legend=dict(\n            orientation='h',\n            yanchor='top',\n            y=-0.2,\n            xanchor='center',\n            x=0.5\n        )\n    )\n)\n\n# Display the first plot\nfig1.show()\n\n\n                        \n                                            \nplace description here\n\n\nCode\n# Calculate trendline for DrySoilDays_Summer_whole\ndry_soil_trend = calculate_trendline(combined_soil_data_dry_aggregated['year'], combined_soil_data_dry_aggregated['DrySoilDays_Summer_whole'])\n\n# Create the second area chart for DrySoilDays_Summer_whole with trendline\nfig2 = go.Figure(\n    data=[\n        go.Scatter(\n            x=combined_soil_data_dry_aggregated['year'],\n            y=combined_soil_data_dry_aggregated['DrySoilDays_Summer_whole'],\n            fill='tozeroy',\n            name='Dry Soil Days in Summer',\n            mode='none',\n            fillcolor='rgba(165,42,42,0.5)'\n        ),\n        go.Scatter(\n            x=combined_soil_data_dry_aggregated['year'],\n            y=dry_soil_trend,\n            mode='lines',\n            name='Trendline',\n            line=dict(color='blue', dash='dash')\n        )\n    ],\n    layout=dict(\n        title='Dry Soil Days in Summer Trend',\n        xaxis_title='Year',\n        yaxis_title='Dry Soil Days',\n        title_font=dict(size=18, family='Arial, sans-serif'),\n        xaxis=dict(tickfont=dict(size=14)),\n        yaxis=dict(tickfont=dict(size=14)),\n        width=800,\n        height=600,\n        plot_bgcolor='#f7f7f7',\n        hoverlabel=dict(font_size=16),\n        showlegend=True,\n        legend=dict(\n            orientation='h',\n            yanchor='top',\n            y=-0.2,\n            xanchor='center',\n            x=0.5\n        )\n    )\n)\n\n# Display the second plot\nfig2.show()\n\n\n                        \n                                            \nplace description here",
    "crumbs": [
      "Chapter 2Ô∏è‚É£",
      "Summer Soil"
    ]
  },
  {
    "objectID": "soil.html#subtitle",
    "href": "soil.html#subtitle",
    "title": "Summer Soil",
    "section": "",
    "text": "More text\n\nüçÇ\n\n\n\n\n\nCode\nimport pandas as pd\nimport plotly.express as px\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport pandas as pd\nimport plotly.graph_objects as go\nimport seaborn as sns\nfrom sklearn.linear_model import LinearRegression\n\n# Load the cleaned datasets\nhistoric_data = pd.read_csv('./data/clean-data/historic_data_cleaned.csv')\nnearterm_data = pd.read_csv('./data/clean-data/nearterm_data_cleaned.csv')\n\n# Combine datasets for some visualizations\ncombined_data = pd.concat([historic_data, nearterm_data])\n\n# Group by year and calculate the average values for Tmax_Summer and VWC_Summer_whole\naverage_data = combined_data.groupby('year').agg({'Tmax_Summer': 'mean', 'VWC_Summer_whole': 'mean'}).reset_index()\n\n# Create the scatter plot to show the relationship between Tmax_Summer and VWC_Summer_whole\nfig = px.scatter(average_data, x='Tmax_Summer', y='VWC_Summer_whole',\n                 trendline='ols',  # Add a trendline\n                 title='Relationship Between Summer Maximum Temperature and Soil Moisture',\n                 labels={'Tmax_Summer': 'Maximum Summer Temperature (¬∞C)', 'VWC_Summer_whole': 'Average Soil Moisture (%)'})\n\n# Update layout for better aesthetics\nfig.update_layout(\n    title_font=dict(size=18, family='Arial, sans-serif'),\n    xaxis_title='Maximum Summer Temperature (¬∞C)',\n    yaxis_title='Average Soil Moisture (%)',\n    width=800,\n    height=600\n)\n\n\n                        \n                                            \nplace description here\n\n\nCode\n# Extracting the relevant column for VWC_Summer_whole analysis\nhistoric_soil_data_vwc = historic_data[['year', 'VWC_Summer_whole']]\nnearterm_soil_data_vwc = nearterm_data[['year', 'VWC_Summer_whole']]\ncombined_soil_data_vwc = pd.concat([historic_soil_data_vwc, nearterm_soil_data_vwc])\ncombined_soil_data_vwc_aggregated = combined_soil_data_vwc.groupby('year').mean().reset_index()\n\n# Extracting the relevant column for DrySoilDays_Summer_whole analysis\nhistoric_soil_data_dry = historic_data[['year', 'DrySoilDays_Summer_whole']]\nnearterm_soil_data_dry = nearterm_data[['year', 'DrySoilDays_Summer_whole']]\ncombined_soil_data_dry = pd.concat([historic_soil_data_dry, nearterm_soil_data_dry])\ncombined_soil_data_dry_aggregated = combined_soil_data_dry.groupby('year').mean().reset_index()\n\n# Function to calculate trendline\ndef calculate_trendline(x, y):\n    model = LinearRegression()\n    x_reshaped = np.array(x).reshape(-1, 1)\n    model.fit(x_reshaped, y)\n    trend = model.predict(x_reshaped)\n    return trend\n\n# Calculate trendline for VWC_Summer_whole\nvwc_trend = calculate_trendline(combined_soil_data_vwc_aggregated['year'], combined_soil_data_vwc_aggregated['VWC_Summer_whole'])\n\n# Determine the y-axis range to better show changes in moisture levels\ny_min = combined_soil_data_vwc_aggregated['VWC_Summer_whole'].min() - 0.005\ny_max = combined_soil_data_vwc_aggregated['VWC_Summer_whole'].max() + 0.005\n\n# Create the first area chart for VWC_Summer_whole with trendline\nfig1 = go.Figure(\n    data=[\n        go.Scatter(\n            x=combined_soil_data_vwc_aggregated['year'],\n            y=combined_soil_data_vwc_aggregated['VWC_Summer_whole'],\n            fill='tozeroy',\n            name='Soil Moisture in Summer',\n            mode='none',\n            fillcolor='#003c54'\n        ),\n        go.Scatter(\n            x=combined_soil_data_vwc_aggregated['year'],\n            y=vwc_trend,\n            mode='lines',\n            name='Trendline',\n            line=dict(color='red', dash='dash')\n        )\n    ],\n    layout=dict(\n        title='Soil Moisture in Summer Trend',\n        xaxis_title='Year',\n        yaxis_title='Soil Moisture (%)',\n        yaxis=dict(range=[y_min, y_max], tickfont=dict(size=14)),  # Set the y-axis range\n        title_font=dict(size=18, family='Arial, sans-serif'),\n        xaxis=dict(tickfont=dict(size=14)),\n        width=800,\n        height=600,\n        plot_bgcolor='#f7f7f7',\n        hoverlabel=dict(font_size=16),\n        showlegend=True,\n        legend=dict(\n            orientation='h',\n            yanchor='top',\n            y=-0.2,\n            xanchor='center',\n            x=0.5\n        )\n    )\n)\n\n# Display the first plot\nfig1.show()\n\n\n                        \n                                            \nplace description here\n\n\nCode\n# Calculate trendline for DrySoilDays_Summer_whole\ndry_soil_trend = calculate_trendline(combined_soil_data_dry_aggregated['year'], combined_soil_data_dry_aggregated['DrySoilDays_Summer_whole'])\n\n# Create the second area chart for DrySoilDays_Summer_whole with trendline\nfig2 = go.Figure(\n    data=[\n        go.Scatter(\n            x=combined_soil_data_dry_aggregated['year'],\n            y=combined_soil_data_dry_aggregated['DrySoilDays_Summer_whole'],\n            fill='tozeroy',\n            name='Dry Soil Days in Summer',\n            mode='none',\n            fillcolor='rgba(165,42,42,0.5)'\n        ),\n        go.Scatter(\n            x=combined_soil_data_dry_aggregated['year'],\n            y=dry_soil_trend,\n            mode='lines',\n            name='Trendline',\n            line=dict(color='blue', dash='dash')\n        )\n    ],\n    layout=dict(\n        title='Dry Soil Days in Summer Trend',\n        xaxis_title='Year',\n        yaxis_title='Dry Soil Days',\n        title_font=dict(size=18, family='Arial, sans-serif'),\n        xaxis=dict(tickfont=dict(size=14)),\n        yaxis=dict(tickfont=dict(size=14)),\n        width=800,\n        height=600,\n        plot_bgcolor='#f7f7f7',\n        hoverlabel=dict(font_size=16),\n        showlegend=True,\n        legend=dict(\n            orientation='h',\n            yanchor='top',\n            y=-0.2,\n            xanchor='center',\n            x=0.5\n        )\n    )\n)\n\n# Display the second plot\nfig2.show()\n\n\n                        \n                                            \nplace description here",
    "crumbs": [
      "Chapter 2Ô∏è‚É£",
      "Summer Soil"
    ]
  },
  {
    "objectID": "evap.html",
    "href": "evap.html",
    "title": "Evaporation",
    "section": "",
    "text": "Text here\n\n\nCode\nlibrary(reticulate)\n\nuse_condaenv(\"base\", required = TRUE)\n\n\n\n\nMore text\n\nüí®\n\n\n\n\n\nCode\nimport pandas as pd\nimport plotly.graph_objects as go\nfrom sklearn.linear_model import LinearRegression\nimport numpy as np\n\n# Load the cleaned datasets\nhistoric_data = pd.read_csv('./data/clean-data/historic_data_cleaned.csv')\nnearterm_data = pd.read_csv('./data/clean-data/nearterm_data_cleaned.csv')\n\n# Combine datasets for some visualizations\ncombined_data = pd.concat([historic_data, nearterm_data])\n\n# Extracting and merging the relevant columns for Evap_Summer analysis\ncombined_evap_data = combined_data[['year', 'Evap_Summer']]\n\n# Aggregating the data by year using the mean\ncombined_evap_aggregated = combined_evap_data.groupby('year').mean().reset_index()\n\n# Calculate trendline for Evap_Summer\ndef calculate_trendline(x, y):\n    model = LinearRegression()\n    x_reshaped = np.array(x).reshape(-1, 1)\n    model.fit(x_reshaped, y)\n    trend = model.predict(x_reshaped)\n    return trend\n\nevap_trend = calculate_trendline(combined_evap_aggregated['year'], combined_evap_aggregated['Evap_Summer'])\n\n# Create the Evaporation in Summer trend plot in one step\nfig1 = go.Figure(\n    data=[\n        go.Scatter(\n            x=combined_evap_aggregated['year'],\n            y=combined_evap_aggregated['Evap_Summer'],\n            mode='lines+markers',\n            line=dict(color='orange'),\n            hovertemplate='Year: %{x}&lt;br&gt;Evaporation: %{y}&lt;extra&gt;&lt;/extra&gt;',\n            name='Evaporation in Summer'\n        ),\n        go.Scatter(\n            x=combined_evap_aggregated['year'],\n            y=evap_trend,\n            mode='lines',\n            line=dict(color='blue', dash='dash'),\n            name='Trendline'\n        )\n    ],\n    layout=dict(\n        title='Evaporation in Summer Trend',\n        xaxis_title='Year',\n        yaxis_title='Evaporation in Summer',\n        title_font=dict(size=18, family='Arial, sans-serif'),\n        xaxis=dict(tickfont=dict(size=14)),\n        yaxis=dict(tickfont=dict(size=14)),\n        width=800,\n        height=600,\n        plot_bgcolor='#f7f7f7',\n        hoverlabel=dict(font_size=16),\n        showlegend=True,\n        legend=dict(\n            orientation='h',\n            yanchor='top',\n            y=-0.2,\n            xanchor='center',\n            x=0.5\n        )\n    )\n)\n\n# Display the first plot\nfig1.show()\n\n\n                        \n                                            \nplace description here\n\n\nCode\n# Extracting and merging the relevant columns for ExtremeShortTermDryStress_Summer_whole analysis\ncombined_dry_stress_data = combined_data[['year', 'ExtremeShortTermDryStress_Summer_whole']]\n\n# Aggregating the data by year using the mean\ncombined_dry_stress_data_aggregated = combined_dry_stress_data.groupby('year').mean().reset_index()\n\n# Calculate trendline for ExtremeShortTermDryStress_Summer_whole\ndry_stress_trend = calculate_trendline(combined_dry_stress_data_aggregated['year'], combined_dry_stress_data_aggregated['ExtremeShortTermDryStress_Summer_whole'])\n\n# Create the Extreme Short Term Dry Stress in Summer trend plot in one step\nfig2 = go.Figure(\n    data=[\n        go.Scatter(\n            x=combined_dry_stress_data_aggregated['year'],\n            y=combined_dry_stress_data_aggregated['ExtremeShortTermDryStress_Summer_whole'],\n            mode='lines+markers',\n            line=dict(color='red'),\n            hovertemplate='Year: %{x}&lt;br&gt;Dry Stress: %{y}&lt;extra&gt;&lt;/extra&gt;',\n            name='Extreme Short Term Dry Stress'\n        ),\n        go.Scatter(\n            x=combined_dry_stress_data_aggregated['year'],\n            y=dry_stress_trend,\n            mode='lines',\n            line=dict(color='blue', dash='dash'),\n            name='Trendline'\n        )\n    ],\n    layout=dict(\n        title='Extreme Short Term Dry Stress in Summer Trend',\n        xaxis_title='Year',\n        yaxis_title='Extreme Short Term Dry Stress in Summer',\n        title_font=dict(size=18, family='Arial, sans-serif'),\n        xaxis=dict(tickfont=dict(size=14)),\n        yaxis=dict(tickfont=dict(size=14)),\n        width=800,\n        height=600,\n        plot_bgcolor='#f7f7f7',\n        hoverlabel=dict(font_size=16),\n        showlegend=True,\n        legend=dict(\n            orientation='h',\n            yanchor='top',\n            y=-0.2,\n            xanchor='center',\n            x=0.5\n        )\n    )\n)\n\n# Display the second plot\nfig2.show()\n\n\n                        \n                                            \nplace description here",
    "crumbs": [
      "Chapter 3Ô∏è‚É£",
      "Evaporation"
    ]
  },
  {
    "objectID": "evap.html#subtitle",
    "href": "evap.html#subtitle",
    "title": "Evaporation",
    "section": "",
    "text": "More text\n\nüí®\n\n\n\n\n\nCode\nimport pandas as pd\nimport plotly.graph_objects as go\nfrom sklearn.linear_model import LinearRegression\nimport numpy as np\n\n# Load the cleaned datasets\nhistoric_data = pd.read_csv('./data/clean-data/historic_data_cleaned.csv')\nnearterm_data = pd.read_csv('./data/clean-data/nearterm_data_cleaned.csv')\n\n# Combine datasets for some visualizations\ncombined_data = pd.concat([historic_data, nearterm_data])\n\n# Extracting and merging the relevant columns for Evap_Summer analysis\ncombined_evap_data = combined_data[['year', 'Evap_Summer']]\n\n# Aggregating the data by year using the mean\ncombined_evap_aggregated = combined_evap_data.groupby('year').mean().reset_index()\n\n# Calculate trendline for Evap_Summer\ndef calculate_trendline(x, y):\n    model = LinearRegression()\n    x_reshaped = np.array(x).reshape(-1, 1)\n    model.fit(x_reshaped, y)\n    trend = model.predict(x_reshaped)\n    return trend\n\nevap_trend = calculate_trendline(combined_evap_aggregated['year'], combined_evap_aggregated['Evap_Summer'])\n\n# Create the Evaporation in Summer trend plot in one step\nfig1 = go.Figure(\n    data=[\n        go.Scatter(\n            x=combined_evap_aggregated['year'],\n            y=combined_evap_aggregated['Evap_Summer'],\n            mode='lines+markers',\n            line=dict(color='orange'),\n            hovertemplate='Year: %{x}&lt;br&gt;Evaporation: %{y}&lt;extra&gt;&lt;/extra&gt;',\n            name='Evaporation in Summer'\n        ),\n        go.Scatter(\n            x=combined_evap_aggregated['year'],\n            y=evap_trend,\n            mode='lines',\n            line=dict(color='blue', dash='dash'),\n            name='Trendline'\n        )\n    ],\n    layout=dict(\n        title='Evaporation in Summer Trend',\n        xaxis_title='Year',\n        yaxis_title='Evaporation in Summer',\n        title_font=dict(size=18, family='Arial, sans-serif'),\n        xaxis=dict(tickfont=dict(size=14)),\n        yaxis=dict(tickfont=dict(size=14)),\n        width=800,\n        height=600,\n        plot_bgcolor='#f7f7f7',\n        hoverlabel=dict(font_size=16),\n        showlegend=True,\n        legend=dict(\n            orientation='h',\n            yanchor='top',\n            y=-0.2,\n            xanchor='center',\n            x=0.5\n        )\n    )\n)\n\n# Display the first plot\nfig1.show()\n\n\n                        \n                                            \nplace description here\n\n\nCode\n# Extracting and merging the relevant columns for ExtremeShortTermDryStress_Summer_whole analysis\ncombined_dry_stress_data = combined_data[['year', 'ExtremeShortTermDryStress_Summer_whole']]\n\n# Aggregating the data by year using the mean\ncombined_dry_stress_data_aggregated = combined_dry_stress_data.groupby('year').mean().reset_index()\n\n# Calculate trendline for ExtremeShortTermDryStress_Summer_whole\ndry_stress_trend = calculate_trendline(combined_dry_stress_data_aggregated['year'], combined_dry_stress_data_aggregated['ExtremeShortTermDryStress_Summer_whole'])\n\n# Create the Extreme Short Term Dry Stress in Summer trend plot in one step\nfig2 = go.Figure(\n    data=[\n        go.Scatter(\n            x=combined_dry_stress_data_aggregated['year'],\n            y=combined_dry_stress_data_aggregated['ExtremeShortTermDryStress_Summer_whole'],\n            mode='lines+markers',\n            line=dict(color='red'),\n            hovertemplate='Year: %{x}&lt;br&gt;Dry Stress: %{y}&lt;extra&gt;&lt;/extra&gt;',\n            name='Extreme Short Term Dry Stress'\n        ),\n        go.Scatter(\n            x=combined_dry_stress_data_aggregated['year'],\n            y=dry_stress_trend,\n            mode='lines',\n            line=dict(color='blue', dash='dash'),\n            name='Trendline'\n        )\n    ],\n    layout=dict(\n        title='Extreme Short Term Dry Stress in Summer Trend',\n        xaxis_title='Year',\n        yaxis_title='Extreme Short Term Dry Stress in Summer',\n        title_font=dict(size=18, family='Arial, sans-serif'),\n        xaxis=dict(tickfont=dict(size=14)),\n        yaxis=dict(tickfont=dict(size=14)),\n        width=800,\n        height=600,\n        plot_bgcolor='#f7f7f7',\n        hoverlabel=dict(font_size=16),\n        showlegend=True,\n        legend=dict(\n            orientation='h',\n            yanchor='top',\n            y=-0.2,\n            xanchor='center',\n            x=0.5\n        )\n    )\n)\n\n# Display the second plot\nfig2.show()\n\n\n                        \n                                            \nplace description here",
    "crumbs": [
      "Chapter 3Ô∏è‚É£",
      "Evaporation"
    ]
  },
  {
    "objectID": "ppt.html",
    "href": "ppt.html",
    "title": "Summer Rain",
    "section": "",
    "text": "Text here\n\n\nCode\nlibrary(reticulate)\n\nuse_condaenv(\"base\", required = TRUE)\n\n\n\n\nMore text\n\nüåßÔ∏è\n\n\n\n\n\nCode\nimport pandas as pd\nimport plotly.express as px\nimport numpy as np\nimport plotly.express as px\nimport numpy as np\nimport seaborn as sns\nimport matplotlib.pyplot as plt\n\n# Load the cleaned datasets\nhistoric_data_1 = pd.read_csv('./data/clean-data/historic_data_cleaned.csv')\nnearterm_data_1 = pd.read_csv('./data/clean-data/nearterm_data_cleaned.csv')\n\n# Combine datasets for some visualizations\ncombined_data_1 = pd.concat([historic_data_1, nearterm_data_1])\n\n# Calculate the center of the map\ncenter_lat_1 = combined_data_1['lat'].mean()\ncenter_long_1 = combined_data_1['long'].mean()\n\n# Function to calculate an appropriate zoom level based on the spread of data points\ndef calculate_zoom_level_1(latitudes_1, longitudes_1):\n    max_lat_1, min_lat_1 = np.max(latitudes_1), np.min(latitudes_1)\n    max_long_1, min_long_1 = np.max(longitudes_1), np.min(longitudes_1)\n    lat_diff_1 = max_lat_1 - min_lat_1\n    long_diff_1 = max_long_1 - min_long_1\n    max_diff_1 = max(lat_diff_1, long_diff_1)\n    \n    if max_diff_1 &lt; 0.01:\n        return 15\n    elif max_diff_1 &lt; 0.1:\n        return 12\n    elif max_diff_1 &lt; 1:\n        return 10\n    elif max_diff_1 &lt; 10:\n        return 8\n    else:\n        return 6\n\n# Calculate zoom level (but we will manually adjust it for more zoom)\nzoom_level_1 = calculate_zoom_level_1(combined_data_1['lat'], combined_data_1['long'])\n\n# Manually adjust zoom level for a more zoomed-in view\nzoom_level_1 = zoom_level_1 * 0.95  # Increase the zoom factor\n\n# Set Mapbox access token\npx.set_mapbox_access_token(\"pk.eyJ1IjoiaXNmYXJiYXNldCIsImEiOiJjbHdiOWVtY2IwbGxsMmtraHZoYnB1YTMwIn0.10XSE1rNVsmXSnFmYYa0Cw\")\n\n# Create the Plotly scatter_mapbox map with enhanced aesthetics and detailed map layers\nmap_fig_1 = px.scatter_mapbox(combined_data_1, lon='long', lat='lat', color='PPT_Summer',\n                              hover_data={'PPT_Summer': ':.2f', 'lat': ':.2f', 'long': ':.2f', 'year': True}, size='PPT_Summer',\n                              labels={'PPT_Summer': 'summer precipitation', 'lat': 'latitude', 'long': 'longitude'},\n                              animation_frame='year', title='Geospatial Distribution of Summer Precipitation Over Time',\n                              color_continuous_scale=px.colors.sequential.Viridis_r, size_max=15, zoom=zoom_level_1,\n                              center={\"lat\": center_lat_1, \"lon\": center_long_1}\n                              )\n\n# Update the layout for better aesthetics and visibility of state lines\nmap_fig_1.update_layout(\n    mapbox_style=\"carto-positron\",  # Change the map style to show more details\n    mapbox=dict(\n        center=dict(lat=center_lat_1, lon=center_long_1),\n        zoom=zoom_level_1,  # Adjusted zoom level\n    ),\n    title_font=dict(size=18, family='Arial, sans-serif'),  \n    title_x=0.5,\n    coloraxis_colorbar=dict(\n        title=\"Summer Precipitation (inches)\",\n        title_side=\"right\",  # Align the title horizontally with the colorbar\n        title_font=dict(size=14)  # Adjust the font size as needed\n    ),\n    autosize=True,\n    width=750,  # Increase the width of the map\n    height=700   # Increase the height of the map\n)\n\n\n                        \n                                            \nplace description here\n\n\nCode\n# Load the cleaned datasets\nhistoric_data_1 = pd.read_csv('./data/clean-data/historic_data_cleaned.csv')\nnearterm_data_1 = pd.read_csv('./data/clean-data/nearterm_data_cleaned.csv')\n\n# Combine datasets for some visualizations\ncombined_data_1 = pd.concat([historic_data_1, nearterm_data_1])\n\n# Extracting the relevant column for analysis\nhistoric_ppt_data = historic_data_1[['year', 'PPT_Summer']]\nnearterm_ppt_data = nearterm_data_1[['year', 'PPT_Summer']]\n\n# Merging both datasets for a comprehensive analysis\ncombined_ppt_data = pd.concat([historic_ppt_data, nearterm_ppt_data])\n\n# Aggregating the data by year using the mean\ncombined_ppt_data_aggregated = combined_ppt_data.groupby('year').mean().reset_index()\n\n# Setting the style of the plot\nsns.set_theme(style=\"whitegrid\")\n\n# Plotting the PPT_Summer over the years with enhancements and a trendline\nplt.figure(figsize=(16, 9))\nsns.lineplot(data=combined_ppt_data_aggregated, x='year', y='PPT_Summer', marker='o', color='navy', linewidth=2.5, label='Summer Precipitation')\nsns.regplot(data=combined_ppt_data_aggregated, x='year', y='PPT_Summer', scatter=False, color='#4682B4', ci=None, line_kws={\"linewidth\":2.5, \"linestyle\":\"--\"}, label='Trendline')\n\n# Adding titles and labels with enhanced aesthetics\nplt.title('Summer Precipitation Trend\\n in Southeastern Utah', fontsize=32)\nplt.xlabel('Year', fontsize=25, weight='bold')\nplt.ylabel('Summer Precipitation (inches)', fontsize=25, weight='bold')\n\n# Setting the x-axis range from 1980 to 2024\n_ = plt.xlim(1980, 2024)\n\n# Adding a grid with customized appearance\n_ = plt.grid(True, linestyle='--', linewidth=0.7, alpha=0.7)\n\n# Enhancing the tick labels for better readability\n_ = plt.xticks(fontsize=20)\n_ = plt.yticks(fontsize=20)\n\n# Adding a light background color to the plot area\nplt.gca().set_facecolor('#f7f7f7')\n\n# Removing the top and right spines for a cleaner look\nsns.despine()\n\n# Adding legend\n_ = plt.legend(fontsize=20)\n\n# Display the plot\nplt.show()\n\n\n\n\n\nplace description here",
    "crumbs": [
      "Chapter 4Ô∏è‚É£",
      "Summer Rain"
    ]
  },
  {
    "objectID": "ppt.html#subtitle",
    "href": "ppt.html#subtitle",
    "title": "Summer Rain",
    "section": "",
    "text": "More text\n\nüåßÔ∏è\n\n\n\n\n\nCode\nimport pandas as pd\nimport plotly.express as px\nimport numpy as np\nimport plotly.express as px\nimport numpy as np\nimport seaborn as sns\nimport matplotlib.pyplot as plt\n\n# Load the cleaned datasets\nhistoric_data_1 = pd.read_csv('./data/clean-data/historic_data_cleaned.csv')\nnearterm_data_1 = pd.read_csv('./data/clean-data/nearterm_data_cleaned.csv')\n\n# Combine datasets for some visualizations\ncombined_data_1 = pd.concat([historic_data_1, nearterm_data_1])\n\n# Calculate the center of the map\ncenter_lat_1 = combined_data_1['lat'].mean()\ncenter_long_1 = combined_data_1['long'].mean()\n\n# Function to calculate an appropriate zoom level based on the spread of data points\ndef calculate_zoom_level_1(latitudes_1, longitudes_1):\n    max_lat_1, min_lat_1 = np.max(latitudes_1), np.min(latitudes_1)\n    max_long_1, min_long_1 = np.max(longitudes_1), np.min(longitudes_1)\n    lat_diff_1 = max_lat_1 - min_lat_1\n    long_diff_1 = max_long_1 - min_long_1\n    max_diff_1 = max(lat_diff_1, long_diff_1)\n    \n    if max_diff_1 &lt; 0.01:\n        return 15\n    elif max_diff_1 &lt; 0.1:\n        return 12\n    elif max_diff_1 &lt; 1:\n        return 10\n    elif max_diff_1 &lt; 10:\n        return 8\n    else:\n        return 6\n\n# Calculate zoom level (but we will manually adjust it for more zoom)\nzoom_level_1 = calculate_zoom_level_1(combined_data_1['lat'], combined_data_1['long'])\n\n# Manually adjust zoom level for a more zoomed-in view\nzoom_level_1 = zoom_level_1 * 0.95  # Increase the zoom factor\n\n# Set Mapbox access token\npx.set_mapbox_access_token(\"pk.eyJ1IjoiaXNmYXJiYXNldCIsImEiOiJjbHdiOWVtY2IwbGxsMmtraHZoYnB1YTMwIn0.10XSE1rNVsmXSnFmYYa0Cw\")\n\n# Create the Plotly scatter_mapbox map with enhanced aesthetics and detailed map layers\nmap_fig_1 = px.scatter_mapbox(combined_data_1, lon='long', lat='lat', color='PPT_Summer',\n                              hover_data={'PPT_Summer': ':.2f', 'lat': ':.2f', 'long': ':.2f', 'year': True}, size='PPT_Summer',\n                              labels={'PPT_Summer': 'summer precipitation', 'lat': 'latitude', 'long': 'longitude'},\n                              animation_frame='year', title='Geospatial Distribution of Summer Precipitation Over Time',\n                              color_continuous_scale=px.colors.sequential.Viridis_r, size_max=15, zoom=zoom_level_1,\n                              center={\"lat\": center_lat_1, \"lon\": center_long_1}\n                              )\n\n# Update the layout for better aesthetics and visibility of state lines\nmap_fig_1.update_layout(\n    mapbox_style=\"carto-positron\",  # Change the map style to show more details\n    mapbox=dict(\n        center=dict(lat=center_lat_1, lon=center_long_1),\n        zoom=zoom_level_1,  # Adjusted zoom level\n    ),\n    title_font=dict(size=18, family='Arial, sans-serif'),  \n    title_x=0.5,\n    coloraxis_colorbar=dict(\n        title=\"Summer Precipitation (inches)\",\n        title_side=\"right\",  # Align the title horizontally with the colorbar\n        title_font=dict(size=14)  # Adjust the font size as needed\n    ),\n    autosize=True,\n    width=750,  # Increase the width of the map\n    height=700   # Increase the height of the map\n)\n\n\n                        \n                                            \nplace description here\n\n\nCode\n# Load the cleaned datasets\nhistoric_data_1 = pd.read_csv('./data/clean-data/historic_data_cleaned.csv')\nnearterm_data_1 = pd.read_csv('./data/clean-data/nearterm_data_cleaned.csv')\n\n# Combine datasets for some visualizations\ncombined_data_1 = pd.concat([historic_data_1, nearterm_data_1])\n\n# Extracting the relevant column for analysis\nhistoric_ppt_data = historic_data_1[['year', 'PPT_Summer']]\nnearterm_ppt_data = nearterm_data_1[['year', 'PPT_Summer']]\n\n# Merging both datasets for a comprehensive analysis\ncombined_ppt_data = pd.concat([historic_ppt_data, nearterm_ppt_data])\n\n# Aggregating the data by year using the mean\ncombined_ppt_data_aggregated = combined_ppt_data.groupby('year').mean().reset_index()\n\n# Setting the style of the plot\nsns.set_theme(style=\"whitegrid\")\n\n# Plotting the PPT_Summer over the years with enhancements and a trendline\nplt.figure(figsize=(16, 9))\nsns.lineplot(data=combined_ppt_data_aggregated, x='year', y='PPT_Summer', marker='o', color='navy', linewidth=2.5, label='Summer Precipitation')\nsns.regplot(data=combined_ppt_data_aggregated, x='year', y='PPT_Summer', scatter=False, color='#4682B4', ci=None, line_kws={\"linewidth\":2.5, \"linestyle\":\"--\"}, label='Trendline')\n\n# Adding titles and labels with enhanced aesthetics\nplt.title('Summer Precipitation Trend\\n in Southeastern Utah', fontsize=32)\nplt.xlabel('Year', fontsize=25, weight='bold')\nplt.ylabel('Summer Precipitation (inches)', fontsize=25, weight='bold')\n\n# Setting the x-axis range from 1980 to 2024\n_ = plt.xlim(1980, 2024)\n\n# Adding a grid with customized appearance\n_ = plt.grid(True, linestyle='--', linewidth=0.7, alpha=0.7)\n\n# Enhancing the tick labels for better readability\n_ = plt.xticks(fontsize=20)\n_ = plt.yticks(fontsize=20)\n\n# Adding a light background color to the plot area\nplt.gca().set_facecolor('#f7f7f7')\n\n# Removing the top and right spines for a cleaner look\nsns.despine()\n\n# Adding legend\n_ = plt.legend(fontsize=20)\n\n# Display the plot\nplt.show()\n\n\n\n\n\nplace description here",
    "crumbs": [
      "Chapter 4Ô∏è‚É£",
      "Summer Rain"
    ]
  },
  {
    "objectID": "max-heat.html",
    "href": "max-heat.html",
    "title": "Maximum Temperature",
    "section": "",
    "text": "Text here\n\n\nCode\nlibrary(reticulate)\n\nuse_condaenv(\"base\", required = TRUE)\n\n\n\n\nMore text\n\nü•µ\n\n\n\n\n\nCode\nimport pandas as pd\nimport plotly.express as px\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport seaborn as sns\n\n# Load the cleaned datasets\nhistoric_data_1 = pd.read_csv('./data/clean-data/historic_data_cleaned.csv')\nnearterm_data_1 = pd.read_csv('./data/clean-data/nearterm_data_cleaned.csv')\n\n# Combine datasets for some visualizations\ncombined_data_1 = pd.concat([historic_data_1, nearterm_data_1])\n\n# Calculate the center of the map\ncenter_lat_1 = combined_data_1['lat'].mean()\ncenter_long_1 = combined_data_1['long'].mean()\n\n# Function to calculate an appropriate zoom level based on the spread of data points\ndef calculate_zoom_level_1(latitudes_1, longitudes_1):\n    max_lat_1, min_lat_1 = np.max(latitudes_1), np.min(latitudes_1)\n    max_long_1, min_long_1 = np.max(longitudes_1), np.min(longitudes_1)\n    lat_diff_1 = max_lat_1 - min_lat_1\n    long_diff_1 = max_long_1 - min_long_1\n    max_diff_1 = max(lat_diff_1, long_diff_1)\n    \n    if max_diff_1 &lt; 0.01:\n        return 15\n    elif max_diff_1 &lt; 0.1:\n        return 12\n    elif max_diff_1 &lt; 1:\n        return 10\n    elif max_diff_1 &lt; 10:\n        return 8\n    else:\n        return 6\n\n# Calculate zoom level (but we will manually adjust it for more zoom)\nzoom_level_1 = calculate_zoom_level_1(combined_data_1['lat'], combined_data_1['long'])\n\n# Manually adjust zoom level for a more zoomed-in view\nzoom_level_1 = zoom_level_1 * 0.95  # Increase the zoom factor\n\n# Set Mapbox access token\npx.set_mapbox_access_token(\"pk.eyJ1IjoiaXNmYXJiYXNldCIsImEiOiJjbHdiOWVtY2IwbGxsMmtraHZoYnB1YTMwIn0.10XSE1rNVsmXSnFmYYa0Cw\")\n\n# Create the Plotly scatter_mapbox map with enhanced aesthetics and detailed map layers\nmap_fig_1 = px.scatter_mapbox(combined_data_1, lon='long', lat='lat', color='Tmax_Summer',\n                            hover_data={'Tmax_Summer': ':.2f', 'lat': ':.2f', 'long': ':.2f', 'year': True}, size='Tmax_Summer',\n                            labels={'Tmax_Summer': 'max temp', 'lat': 'latitude', 'long': 'longitude'},\n                            animation_frame='year', title='Geospatial Distribution of Maximum Temperature Over Time',\n                            color_continuous_scale=px.colors.sequential.Sunsetdark, size_max=15, zoom=zoom_level_1,\n                            center={\"lat\": center_lat_1, \"lon\": center_long_1}\n                            )\n\n# Update the layout for better aesthetics and visibility of state lines\nmap_fig_1.update_layout(\n    mapbox_style=\"carto-positron\",  # Change the map style to show more details\n    mapbox=dict(\n        center=dict(lat=center_lat_1, lon=center_long_1),\n        zoom=zoom_level_1,  # Adjusted zoom level\n    ),\n    title_font=dict(size=18, family='Arial, sans-serif'),  \n    title_x=0.5,\n    coloraxis_colorbar=dict(\n        title=\"Maximum Temperature(¬∞C)\",\n        title_side=\"right\",  # Align the title horizontally with the colorbar\n        title_font=dict(size=14)  # Adjust the font size as needed\n    ),\n    autosize=True,\n    width=750,  # Increase the width of the map\n    height=700   # Increase the height of the map\n)\n\n\n                        \n                                            \nplace description here\n\n\nCode\n# Extracting the relevant column for analysis\nhistoric_tmax_data = historic_data_1[['year', 'Tmax_Summer']]\nnearterm_tmax_data = nearterm_data_1[['year', 'Tmax_Summer']]\n\n# Merging both datasets for a comprehensive analysis\ncombined_tmax_data = pd.concat([historic_tmax_data, nearterm_tmax_data])\n\n# Aggregating the data by year using the mean\ncombined_tmax_data_aggregated = combined_tmax_data.groupby('year').mean().reset_index()\n\n# Setting the style of the plot\nsns.set_theme(style=\"whitegrid\")\n\n# Plotting the Tmax_Summer over the years with enhancements\nplt.figure(figsize=(16, 9))\nsns.lineplot(data=combined_tmax_data_aggregated, x='year', y='Tmax_Summer', marker='o', color='#AA4A44', linewidth=2.5)\n\n# Adding titles and labels with enhanced aesthetics\nplt.title('Maximum Temperature Trend\\n in Southeastern Utah', fontsize=32)\nplt.xlabel('Year', fontsize=25, weight='bold')\nplt.ylabel('Maximum Temperature (¬∞C)', fontsize=25, weight='bold')\n\n# Adding a grid with customized appearance\nplt.grid(True, linestyle='--', linewidth=0.7, alpha=0.7)\n\n# Enhancing the tick labels for better readability\n_ = plt.xticks(fontsize=20)\n_ = plt.yticks(fontsize=20)\n\n# Adding a light background color to the plot area\nplt.gca().set_facecolor('#f7f7f7')\n\n# Removing the top and right spines for a cleaner look\nsns.despine()\n\n# Display the plot\nplt.show()\n\n\n\n\n\nplace description here",
    "crumbs": [
      "1Ô∏è‚É£",
      "Maximum Temperature"
    ]
  },
  {
    "objectID": "max-heat.html#subtitle",
    "href": "max-heat.html#subtitle",
    "title": "Maximum Temperature",
    "section": "",
    "text": "More text\n\nü•µ\n\n\n\n\n\nCode\nimport pandas as pd\nimport plotly.express as px\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport seaborn as sns\n\n# Load the cleaned datasets\nhistoric_data_1 = pd.read_csv('./data/clean-data/historic_data_cleaned.csv')\nnearterm_data_1 = pd.read_csv('./data/clean-data/nearterm_data_cleaned.csv')\n\n# Combine datasets for some visualizations\ncombined_data_1 = pd.concat([historic_data_1, nearterm_data_1])\n\n# Calculate the center of the map\ncenter_lat_1 = combined_data_1['lat'].mean()\ncenter_long_1 = combined_data_1['long'].mean()\n\n# Function to calculate an appropriate zoom level based on the spread of data points\ndef calculate_zoom_level_1(latitudes_1, longitudes_1):\n    max_lat_1, min_lat_1 = np.max(latitudes_1), np.min(latitudes_1)\n    max_long_1, min_long_1 = np.max(longitudes_1), np.min(longitudes_1)\n    lat_diff_1 = max_lat_1 - min_lat_1\n    long_diff_1 = max_long_1 - min_long_1\n    max_diff_1 = max(lat_diff_1, long_diff_1)\n    \n    if max_diff_1 &lt; 0.01:\n        return 15\n    elif max_diff_1 &lt; 0.1:\n        return 12\n    elif max_diff_1 &lt; 1:\n        return 10\n    elif max_diff_1 &lt; 10:\n        return 8\n    else:\n        return 6\n\n# Calculate zoom level (but we will manually adjust it for more zoom)\nzoom_level_1 = calculate_zoom_level_1(combined_data_1['lat'], combined_data_1['long'])\n\n# Manually adjust zoom level for a more zoomed-in view\nzoom_level_1 = zoom_level_1 * 0.95  # Increase the zoom factor\n\n# Set Mapbox access token\npx.set_mapbox_access_token(\"pk.eyJ1IjoiaXNmYXJiYXNldCIsImEiOiJjbHdiOWVtY2IwbGxsMmtraHZoYnB1YTMwIn0.10XSE1rNVsmXSnFmYYa0Cw\")\n\n# Create the Plotly scatter_mapbox map with enhanced aesthetics and detailed map layers\nmap_fig_1 = px.scatter_mapbox(combined_data_1, lon='long', lat='lat', color='Tmax_Summer',\n                            hover_data={'Tmax_Summer': ':.2f', 'lat': ':.2f', 'long': ':.2f', 'year': True}, size='Tmax_Summer',\n                            labels={'Tmax_Summer': 'max temp', 'lat': 'latitude', 'long': 'longitude'},\n                            animation_frame='year', title='Geospatial Distribution of Maximum Temperature Over Time',\n                            color_continuous_scale=px.colors.sequential.Sunsetdark, size_max=15, zoom=zoom_level_1,\n                            center={\"lat\": center_lat_1, \"lon\": center_long_1}\n                            )\n\n# Update the layout for better aesthetics and visibility of state lines\nmap_fig_1.update_layout(\n    mapbox_style=\"carto-positron\",  # Change the map style to show more details\n    mapbox=dict(\n        center=dict(lat=center_lat_1, lon=center_long_1),\n        zoom=zoom_level_1,  # Adjusted zoom level\n    ),\n    title_font=dict(size=18, family='Arial, sans-serif'),  \n    title_x=0.5,\n    coloraxis_colorbar=dict(\n        title=\"Maximum Temperature(¬∞C)\",\n        title_side=\"right\",  # Align the title horizontally with the colorbar\n        title_font=dict(size=14)  # Adjust the font size as needed\n    ),\n    autosize=True,\n    width=750,  # Increase the width of the map\n    height=700   # Increase the height of the map\n)\n\n\n                        \n                                            \nplace description here\n\n\nCode\n# Extracting the relevant column for analysis\nhistoric_tmax_data = historic_data_1[['year', 'Tmax_Summer']]\nnearterm_tmax_data = nearterm_data_1[['year', 'Tmax_Summer']]\n\n# Merging both datasets for a comprehensive analysis\ncombined_tmax_data = pd.concat([historic_tmax_data, nearterm_tmax_data])\n\n# Aggregating the data by year using the mean\ncombined_tmax_data_aggregated = combined_tmax_data.groupby('year').mean().reset_index()\n\n# Setting the style of the plot\nsns.set_theme(style=\"whitegrid\")\n\n# Plotting the Tmax_Summer over the years with enhancements\nplt.figure(figsize=(16, 9))\nsns.lineplot(data=combined_tmax_data_aggregated, x='year', y='Tmax_Summer', marker='o', color='#AA4A44', linewidth=2.5)\n\n# Adding titles and labels with enhanced aesthetics\nplt.title('Maximum Temperature Trend\\n in Southeastern Utah', fontsize=32)\nplt.xlabel('Year', fontsize=25, weight='bold')\nplt.ylabel('Maximum Temperature (¬∞C)', fontsize=25, weight='bold')\n\n# Adding a grid with customized appearance\nplt.grid(True, linestyle='--', linewidth=0.7, alpha=0.7)\n\n# Enhancing the tick labels for better readability\n_ = plt.xticks(fontsize=20)\n_ = plt.yticks(fontsize=20)\n\n# Adding a light background color to the plot area\nplt.gca().set_facecolor('#f7f7f7')\n\n# Removing the top and right spines for a cleaner look\nsns.despine()\n\n# Display the plot\nplt.show()\n\n\n\n\n\nplace description here",
    "crumbs": [
      "1Ô∏è‚É£",
      "Maximum Temperature"
    ]
  },
  {
    "objectID": "temp.html",
    "href": "temp.html",
    "title": "Summer Temperature",
    "section": "",
    "text": "Text here\n\n\nCode\nlibrary(reticulate)\n\nuse_condaenv(\"base\", required = TRUE)\n\n\n\n\nMore text\n\nü•µ\n\n\n\n\n\nCode\nimport pandas as pd\nimport plotly.graph_objects as go\nfrom sklearn.linear_model import LinearRegression\nimport numpy as np\n\n# Load the cleaned datasets\nhistoric_data = pd.read_csv('./data/clean-data/historic_data_cleaned.csv')\nnearterm_data = pd.read_csv('./data/clean-data/nearterm_data_cleaned.csv')\n\n# Combine datasets for some visualizations\ncombined_data = pd.concat([historic_data, nearterm_data])\n\n# Extracting and merging the relevant columns for T_Summer analysis\ncombined_t_summer_data = combined_data[['year', 'T_Summer']]\n\n# Aggregating the data by year using the mean\ncombined_t_summer_aggregated = combined_t_summer_data.groupby('year').mean().reset_index()\n\n# Calculate trendline for combined data\ndef calculate_trendline(x, y):\n    model = LinearRegression()\n    x_reshaped = np.array(x).reshape(-1, 1)\n    model.fit(x_reshaped, y)\n    trend = model.predict(x_reshaped)\n    return trend\n\nt_summer_trend = calculate_trendline(combined_t_summer_aggregated['year'], combined_t_summer_aggregated['T_Summer'])\n\n# Create a custom colorscale with cerulean for lower values and deep navy blue for higher values\ncustom_colorscale = [\n    [0.0, 'rgb(255,192,12)'],  # yellow ochre\n    [1.0,  'rgb(150,0,0)']  # deep navy red\n]\n\n# Create bubble chart with trendline and update layout\nfig = go.Figure(\n    data=[\n        go.Scatter(\n            x=combined_t_summer_aggregated['year'],\n            y=combined_t_summer_aggregated['T_Summer'],\n            mode='markers',\n            marker=dict(\n                size=combined_t_summer_aggregated['T_Summer'],\n                color=combined_t_summer_aggregated['T_Summer'],\n                colorscale=custom_colorscale,\n                sizemode='area',\n                sizeref=2.*max(combined_t_summer_aggregated['T_Summer'])/(40.**2),  # Adjusted sizeref to make bubbles smaller\n                sizemin=3  # Adjusted sizemin to make the smallest bubbles smaller\n            ),\n            hovertemplate='Year: %{x}&lt;br&gt;Temperature: %{y:.2f} ¬∞C&lt;extra&gt;&lt;/extra&gt;',\n            name='Summer Temperature'\n        ),\n        go.Scatter(\n            x=combined_t_summer_aggregated['year'],\n            y=t_summer_trend,\n            mode='lines',\n            line=dict(color='red', dash='dash'),\n            hovertemplate='Year: %{x}&lt;br&gt;Trend: %{y:.2f} ¬∞C&lt;extra&gt;&lt;/extra&gt;',\n            name='Trendline'\n        )\n    ],\n    layout=dict(\n        title='Summer Temperature Trend',\n        xaxis_title='Year',\n        yaxis_title='Summer Temperature (¬∞C)',\n        title_font=dict(size=18, family='Arial, sans-serif'),\n        xaxis=dict(tickfont=dict(size=14)),\n        yaxis=dict(tickfont=dict(size=14)),\n        width=800,\n        height=600,\n        plot_bgcolor='#f7f7f7',\n        hoverlabel=dict(font_size=16),\n        showlegend=False,\n        legend=dict(\n            orientation='h',\n            yanchor='top',\n            y=-0.2,\n            xanchor='center',\n            x=0.5\n        )\n    )\n)\n\n# Display the plot\nfig.show()\n\n\n                        \n                                            \nplace description here",
    "crumbs": [
      "Chapter 1Ô∏è‚É£",
      "Summer Temperature"
    ]
  },
  {
    "objectID": "temp.html#subtitle",
    "href": "temp.html#subtitle",
    "title": "Summer Temperature",
    "section": "",
    "text": "More text\n\nü•µ\n\n\n\n\n\nCode\nimport pandas as pd\nimport plotly.graph_objects as go\nfrom sklearn.linear_model import LinearRegression\nimport numpy as np\n\n# Load the cleaned datasets\nhistoric_data = pd.read_csv('./data/clean-data/historic_data_cleaned.csv')\nnearterm_data = pd.read_csv('./data/clean-data/nearterm_data_cleaned.csv')\n\n# Combine datasets for some visualizations\ncombined_data = pd.concat([historic_data, nearterm_data])\n\n# Extracting and merging the relevant columns for T_Summer analysis\ncombined_t_summer_data = combined_data[['year', 'T_Summer']]\n\n# Aggregating the data by year using the mean\ncombined_t_summer_aggregated = combined_t_summer_data.groupby('year').mean().reset_index()\n\n# Calculate trendline for combined data\ndef calculate_trendline(x, y):\n    model = LinearRegression()\n    x_reshaped = np.array(x).reshape(-1, 1)\n    model.fit(x_reshaped, y)\n    trend = model.predict(x_reshaped)\n    return trend\n\nt_summer_trend = calculate_trendline(combined_t_summer_aggregated['year'], combined_t_summer_aggregated['T_Summer'])\n\n# Create a custom colorscale with cerulean for lower values and deep navy blue for higher values\ncustom_colorscale = [\n    [0.0, 'rgb(255,192,12)'],  # yellow ochre\n    [1.0,  'rgb(150,0,0)']  # deep navy red\n]\n\n# Create bubble chart with trendline and update layout\nfig = go.Figure(\n    data=[\n        go.Scatter(\n            x=combined_t_summer_aggregated['year'],\n            y=combined_t_summer_aggregated['T_Summer'],\n            mode='markers',\n            marker=dict(\n                size=combined_t_summer_aggregated['T_Summer'],\n                color=combined_t_summer_aggregated['T_Summer'],\n                colorscale=custom_colorscale,\n                sizemode='area',\n                sizeref=2.*max(combined_t_summer_aggregated['T_Summer'])/(40.**2),  # Adjusted sizeref to make bubbles smaller\n                sizemin=3  # Adjusted sizemin to make the smallest bubbles smaller\n            ),\n            hovertemplate='Year: %{x}&lt;br&gt;Temperature: %{y:.2f} ¬∞C&lt;extra&gt;&lt;/extra&gt;',\n            name='Summer Temperature'\n        ),\n        go.Scatter(\n            x=combined_t_summer_aggregated['year'],\n            y=t_summer_trend,\n            mode='lines',\n            line=dict(color='red', dash='dash'),\n            hovertemplate='Year: %{x}&lt;br&gt;Trend: %{y:.2f} ¬∞C&lt;extra&gt;&lt;/extra&gt;',\n            name='Trendline'\n        )\n    ],\n    layout=dict(\n        title='Summer Temperature Trend',\n        xaxis_title='Year',\n        yaxis_title='Summer Temperature (¬∞C)',\n        title_font=dict(size=18, family='Arial, sans-serif'),\n        xaxis=dict(tickfont=dict(size=14)),\n        yaxis=dict(tickfont=dict(size=14)),\n        width=800,\n        height=600,\n        plot_bgcolor='#f7f7f7',\n        hoverlabel=dict(font_size=16),\n        showlegend=False,\n        legend=dict(\n            orientation='h',\n            yanchor='top',\n            y=-0.2,\n            xanchor='center',\n            x=0.5\n        )\n    )\n)\n\n# Display the plot\nfig.show()\n\n\n                        \n                                            \nplace description here",
    "crumbs": [
      "Chapter 1Ô∏è‚É£",
      "Summer Temperature"
    ]
  }
]